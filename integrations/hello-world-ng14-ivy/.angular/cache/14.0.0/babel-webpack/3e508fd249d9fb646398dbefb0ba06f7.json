{
  "ast": null,
  "code": "import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, APP_INITIALIZER, NgModule } from '@angular/core';\nimport * as i1 from '@ngxs/store';\nimport { ofActionDispatched, getValue } from '@ngxs/store';\nimport { Subscription } from 'rxjs';\nimport { WebSocketSubject } from 'rxjs/webSocket';\nconst NGXS_WEBSOCKET_OPTIONS = new InjectionToken('NGXS_WEBSOCKET_OPTIONS');\n\nfunction noop(..._args) {\n  return function () {};\n}\n/**\n * Action to connect to the websocket. Optionally pass a URL.\n */\n\n\nclass ConnectWebSocket {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[WebSocket] Connect';\n  }\n\n}\n/**\n * Action triggered when a error ocurrs\n */\n\n\nclass WebsocketMessageError {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[WebSocket] Message Error';\n  }\n\n}\n/**\n * Action to disconnect the websocket.\n */\n\n\nclass DisconnectWebSocket {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[WebSocket] Disconnect';\n  }\n\n}\n/**\n * Action triggered when websocket is connected\n */\n\n\nclass WebSocketConnected {\n  static get type() {\n    return '[WebSocket] Connected';\n  }\n\n}\n/**\n * Action triggered when websocket is disconnected\n */\n\n\nclass WebSocketDisconnected {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[WebSocket] Disconnected';\n  }\n\n}\n/**\n * Action to send to the server.\n */\n\n\nclass SendWebSocketMessage {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[WebSocket] Send Message';\n  }\n\n}\n/**\n * Action dispatched when the user tries to connect if the connection already exists.\n */\n\n\nclass WebSocketConnectionUpdated {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[WebSocket] Connection Updated';\n  }\n\n}\n/**\n * This error is thrown where there is no `type` (or custom `typeKey`) property\n * on the message that came from the server side socket\n */\n\n\nclass TypeKeyPropertyMissingError extends Error {\n  constructor(typeKey) {\n    super(`Property ${typeKey} is missing on the socket message`);\n  }\n\n}\n\nclass WebSocketHandler {\n  constructor(store, actions$, options) {\n    this.store = store;\n    this.actions$ = actions$;\n    this.options = options;\n    this.socket = null;\n    this.config = {\n      url: this.options.url,\n      protocol: this.options.protocol,\n      // Default binary type is `blob` for the global `WebSocket`\n      binaryType: this.options.binaryType,\n      serializer: this.options.serializer,\n      deserializer: this.options.deserializer,\n      closeObserver: {\n        next: () => {\n          // ATTENTION!\n          // See https://github.com/ReactiveX/rxjs/blob/master/src/internal/observable/dom/WebSocketSubject.ts#L340\n          // RxJS socket emits `onComplete` event only if `event.wasClean` is truthy\n          // and doesn't complete socket subject if it's falsy\n          this.disconnect();\n        }\n      },\n      openObserver: {\n        next: () => this.store.dispatch(new WebSocketConnected())\n      }\n    };\n    this.typeKey = this.options.typeKey;\n    this.subscription = new Subscription();\n    this.setupActionsListeners();\n  }\n\n  ngOnDestroy() {\n    this.closeConnection();\n    this.subscription.unsubscribe();\n  }\n\n  setupActionsListeners() {\n    this.subscription.add(this.actions$.pipe(ofActionDispatched(ConnectWebSocket)).subscribe(({\n      payload\n    }) => {\n      this.connect(payload);\n    }));\n    this.subscription.add(this.actions$.pipe(ofActionDispatched(DisconnectWebSocket)).subscribe(() => {\n      this.disconnect();\n    }));\n    this.subscription.add(this.actions$.pipe(ofActionDispatched(SendWebSocketMessage)).subscribe(({\n      payload\n    }) => {\n      this.send(payload);\n    }));\n  }\n\n  connect(options) {\n    this.updateConnection(); // Users can pass the options in the connect method so\n    // if options aren't available at DI bootstrap they have access\n    // to pass them here\n\n    if (options) {\n      this.mergeConfigWithOptions(options);\n    }\n\n    this.socket = new WebSocketSubject(this.config);\n    this.socket.subscribe({\n      next: message => {\n        const type = getValue(message, this.typeKey);\n\n        if (!type) {\n          throw new TypeKeyPropertyMissingError(this.typeKey);\n        }\n\n        this.store.dispatch(Object.assign(Object.assign({}, message), {\n          type\n        }));\n      },\n      error: error => {\n        if (error instanceof CloseEvent) {\n          this.dispatchWebSocketDisconnected();\n        } else {\n          this.store.dispatch(new WebsocketMessageError(error));\n        }\n      }\n    });\n  }\n\n  disconnect() {\n    if (this.socket) {\n      this.closeConnection();\n      this.dispatchWebSocketDisconnected();\n    }\n  }\n\n  send(data) {\n    if (!this.socket) {\n      throw new Error('You must connect to the socket before sending any data');\n    }\n\n    this.socket.next(data);\n  }\n  /**\n   * Don't enlarge the `connect` method\n   */\n\n\n  mergeConfigWithOptions(options) {\n    if (options.url) {\n      this.config.url = options.url;\n    }\n\n    if (options.serializer) {\n      this.config.serializer = options.serializer;\n    }\n\n    if (options.deserializer) {\n      this.config.deserializer = options.deserializer;\n    }\n  }\n  /**\n   * To ensure we don't have any memory leaks\n   * e.g. if the user occasionally dispatched `ConnectWebSocket` twice\n   * then the previous subscription will still live in the memory\n   * to prevent such behavior - we close the previous connection if it exists\n   */\n\n\n  updateConnection() {\n    if (this.socket) {\n      this.closeConnection();\n      this.store.dispatch(new WebSocketConnectionUpdated());\n    }\n  }\n  /**\n   * Used in many places so it's better to move the code into function\n   */\n\n\n  dispatchWebSocketDisconnected() {\n    this.store.dispatch(new WebSocketDisconnected());\n  }\n\n  closeConnection() {\n    // `socket.complete()` closes the connection\n    // also it doesn't invoke the `onComplete` callback that we passed\n    // into `socket.subscribe(...)`\n    if (this.socket !== null) {\n      this.socket.complete();\n      this.socket = null;\n    }\n  }\n\n}\n/** @nocollapse */\n\n\nWebSocketHandler.ɵfac = function WebSocketHandler_Factory(t) {\n  return new (t || WebSocketHandler)(i0.ɵɵinject(i1.Store), i0.ɵɵinject(i1.Actions), i0.ɵɵinject(NGXS_WEBSOCKET_OPTIONS));\n};\n/** @nocollapse */\n\n\nWebSocketHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: WebSocketHandler,\n  factory: WebSocketHandler.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(WebSocketHandler, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.Store\n    }, {\n      type: i1.Actions\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_WEBSOCKET_OPTIONS]\n      }]\n    }];\n  }, null);\n})();\n\nfunction websocketOptionsFactory(options) {\n  return Object.assign({\n    reconnectInterval: 5000,\n    reconnectAttempts: 10,\n    typeKey: 'type',\n\n    deserializer(e) {\n      return JSON.parse(e.data);\n    },\n\n    serializer(value) {\n      return JSON.stringify(value);\n    }\n\n  }, options);\n}\n\nconst USER_OPTIONS = new InjectionToken('USER_OPTIONS');\n\nclass NgxsWebsocketPluginModule {\n  static forRoot(options) {\n    return {\n      ngModule: NgxsWebsocketPluginModule,\n      providers: [WebSocketHandler, {\n        provide: USER_OPTIONS,\n        useValue: options\n      }, {\n        provide: NGXS_WEBSOCKET_OPTIONS,\n        useFactory: websocketOptionsFactory,\n        deps: [USER_OPTIONS]\n      }, {\n        provide: APP_INITIALIZER,\n        useFactory: noop,\n        deps: [WebSocketHandler],\n        multi: true\n      }]\n    };\n  }\n\n}\n/** @nocollapse */\n\n\nNgxsWebsocketPluginModule.ɵfac = function NgxsWebsocketPluginModule_Factory(t) {\n  return new (t || NgxsWebsocketPluginModule)();\n};\n/** @nocollapse */\n\n\nNgxsWebsocketPluginModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsWebsocketPluginModule\n});\n/** @nocollapse */\n\nNgxsWebsocketPluginModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsWebsocketPluginModule, [{\n    type: NgModule\n  }], null, null);\n})();\n/**\n * The public api for consumers of @ngxs/websocket-plugin\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ConnectWebSocket, DisconnectWebSocket, NGXS_WEBSOCKET_OPTIONS, NgxsWebsocketPluginModule, SendWebSocketMessage, WebSocketConnected, WebSocketConnectionUpdated, WebSocketDisconnected, WebsocketMessageError }; //# sourceMappingURL=ngxs-websocket-plugin.js.map",
  "map": null,
  "metadata": {},
  "sourceType": "module"
}
