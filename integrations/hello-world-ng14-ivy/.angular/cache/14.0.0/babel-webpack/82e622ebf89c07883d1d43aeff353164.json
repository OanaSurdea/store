{
  "ast": null,
  "code": "import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, APP_INITIALIZER, NgModule } from '@angular/core';\nimport * as i1 from '@ngxs/store';\nimport { ofActionDispatched, getValue } from '@ngxs/store';\nimport { Subscription } from 'rxjs';\nimport { WebSocketSubject } from 'rxjs/webSocket';\nconst NGXS_WEBSOCKET_OPTIONS = new InjectionToken('NGXS_WEBSOCKET_OPTIONS');\n\nfunction noop(..._args) {\n  return function () {};\n}\n/**\n * Action to connect to the websocket. Optionally pass a URL.\n */\n\n\nclass ConnectWebSocket {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[WebSocket] Connect';\n  }\n\n}\n/**\n * Action triggered when a error ocurrs\n */\n\n\nclass WebsocketMessageError {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[WebSocket] Message Error';\n  }\n\n}\n/**\n * Action to disconnect the websocket.\n */\n\n\nclass DisconnectWebSocket {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[WebSocket] Disconnect';\n  }\n\n}\n/**\n * Action triggered when websocket is connected\n */\n\n\nclass WebSocketConnected {\n  static get type() {\n    return '[WebSocket] Connected';\n  }\n\n}\n/**\n * Action triggered when websocket is disconnected\n */\n\n\nclass WebSocketDisconnected {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[WebSocket] Disconnected';\n  }\n\n}\n/**\n * Action to send to the server.\n */\n\n\nclass SendWebSocketMessage {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[WebSocket] Send Message';\n  }\n\n}\n/**\n * Action dispatched when the user tries to connect if the connection already exists.\n */\n\n\nclass WebSocketConnectionUpdated {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[WebSocket] Connection Updated';\n  }\n\n}\n/**\n * This error is thrown where there is no `type` (or custom `typeKey`) property\n * on the message that came from the server side socket\n */\n\n\nclass TypeKeyPropertyMissingError extends Error {\n  constructor(typeKey) {\n    super(`Property ${typeKey} is missing on the socket message`);\n  }\n\n}\n\nlet WebSocketHandler = /*#__PURE__*/(() => {\n  class WebSocketHandler {\n    constructor(store, actions$, options) {\n      this.store = store;\n      this.actions$ = actions$;\n      this.options = options;\n      this.socket = null;\n      this.config = {\n        url: this.options.url,\n        protocol: this.options.protocol,\n        // Default binary type is `blob` for the global `WebSocket`\n        binaryType: this.options.binaryType,\n        serializer: this.options.serializer,\n        deserializer: this.options.deserializer,\n        closeObserver: {\n          next: () => {\n            // ATTENTION!\n            // See https://github.com/ReactiveX/rxjs/blob/master/src/internal/observable/dom/WebSocketSubject.ts#L340\n            // RxJS socket emits `onComplete` event only if `event.wasClean` is truthy\n            // and doesn't complete socket subject if it's falsy\n            this.disconnect();\n          }\n        },\n        openObserver: {\n          next: () => this.store.dispatch(new WebSocketConnected())\n        }\n      };\n      this.typeKey = this.options.typeKey;\n      this.subscription = new Subscription();\n      this.setupActionsListeners();\n    }\n\n    ngOnDestroy() {\n      this.closeConnection();\n      this.subscription.unsubscribe();\n    }\n\n    setupActionsListeners() {\n      this.subscription.add(this.actions$.pipe(ofActionDispatched(ConnectWebSocket)).subscribe(({\n        payload\n      }) => {\n        this.connect(payload);\n      }));\n      this.subscription.add(this.actions$.pipe(ofActionDispatched(DisconnectWebSocket)).subscribe(() => {\n        this.disconnect();\n      }));\n      this.subscription.add(this.actions$.pipe(ofActionDispatched(SendWebSocketMessage)).subscribe(({\n        payload\n      }) => {\n        this.send(payload);\n      }));\n    }\n\n    connect(options) {\n      this.updateConnection(); // Users can pass the options in the connect method so\n      // if options aren't available at DI bootstrap they have access\n      // to pass them here\n\n      if (options) {\n        this.mergeConfigWithOptions(options);\n      }\n\n      this.socket = new WebSocketSubject(this.config);\n      this.socket.subscribe({\n        next: message => {\n          const type = getValue(message, this.typeKey);\n\n          if (!type) {\n            throw new TypeKeyPropertyMissingError(this.typeKey);\n          }\n\n          this.store.dispatch(Object.assign(Object.assign({}, message), {\n            type\n          }));\n        },\n        error: error => {\n          if (error instanceof CloseEvent) {\n            this.dispatchWebSocketDisconnected();\n          } else {\n            this.store.dispatch(new WebsocketMessageError(error));\n          }\n        }\n      });\n    }\n\n    disconnect() {\n      if (this.socket) {\n        this.closeConnection();\n        this.dispatchWebSocketDisconnected();\n      }\n    }\n\n    send(data) {\n      if (!this.socket) {\n        throw new Error('You must connect to the socket before sending any data');\n      }\n\n      this.socket.next(data);\n    }\n    /**\n     * Don't enlarge the `connect` method\n     */\n\n\n    mergeConfigWithOptions(options) {\n      if (options.url) {\n        this.config.url = options.url;\n      }\n\n      if (options.serializer) {\n        this.config.serializer = options.serializer;\n      }\n\n      if (options.deserializer) {\n        this.config.deserializer = options.deserializer;\n      }\n    }\n    /**\n     * To ensure we don't have any memory leaks\n     * e.g. if the user occasionally dispatched `ConnectWebSocket` twice\n     * then the previous subscription will still live in the memory\n     * to prevent such behavior - we close the previous connection if it exists\n     */\n\n\n    updateConnection() {\n      if (this.socket) {\n        this.closeConnection();\n        this.store.dispatch(new WebSocketConnectionUpdated());\n      }\n    }\n    /**\n     * Used in many places so it's better to move the code into function\n     */\n\n\n    dispatchWebSocketDisconnected() {\n      this.store.dispatch(new WebSocketDisconnected());\n    }\n\n    closeConnection() {\n      // `socket.complete()` closes the connection\n      // also it doesn't invoke the `onComplete` callback that we passed\n      // into `socket.subscribe(...)`\n      if (this.socket !== null) {\n        this.socket.complete();\n        this.socket = null;\n      }\n    }\n\n  }\n\n  /** @nocollapse */\n  WebSocketHandler.ɵfac = function WebSocketHandler_Factory(t) {\n    return new (t || WebSocketHandler)(i0.ɵɵinject(i1.Store), i0.ɵɵinject(i1.Actions), i0.ɵɵinject(NGXS_WEBSOCKET_OPTIONS));\n  };\n  /** @nocollapse */\n\n\n  WebSocketHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: WebSocketHandler,\n    factory: WebSocketHandler.ɵfac\n  });\n  return WebSocketHandler;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction websocketOptionsFactory(options) {\n  return Object.assign({\n    reconnectInterval: 5000,\n    reconnectAttempts: 10,\n    typeKey: 'type',\n\n    deserializer(e) {\n      return JSON.parse(e.data);\n    },\n\n    serializer(value) {\n      return JSON.stringify(value);\n    }\n\n  }, options);\n}\n\nconst USER_OPTIONS = new InjectionToken('USER_OPTIONS');\nlet NgxsWebsocketPluginModule = /*#__PURE__*/(() => {\n  class NgxsWebsocketPluginModule {\n    static forRoot(options) {\n      return {\n        ngModule: NgxsWebsocketPluginModule,\n        providers: [WebSocketHandler, {\n          provide: USER_OPTIONS,\n          useValue: options\n        }, {\n          provide: NGXS_WEBSOCKET_OPTIONS,\n          useFactory: websocketOptionsFactory,\n          deps: [USER_OPTIONS]\n        }, {\n          provide: APP_INITIALIZER,\n          useFactory: noop,\n          deps: [WebSocketHandler],\n          multi: true\n        }]\n      };\n    }\n\n  }\n\n  /** @nocollapse */\n  NgxsWebsocketPluginModule.ɵfac = function NgxsWebsocketPluginModule_Factory(t) {\n    return new (t || NgxsWebsocketPluginModule)();\n  };\n  /** @nocollapse */\n\n\n  NgxsWebsocketPluginModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsWebsocketPluginModule\n  });\n  /** @nocollapse */\n\n  NgxsWebsocketPluginModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NgxsWebsocketPluginModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The public api for consumers of @ngxs/websocket-plugin\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ConnectWebSocket, DisconnectWebSocket, NGXS_WEBSOCKET_OPTIONS, NgxsWebsocketPluginModule, SendWebSocketMessage, WebSocketConnected, WebSocketConnectionUpdated, WebSocketDisconnected, WebsocketMessageError }; //# sourceMappingURL=ngxs-websocket-plugin.js.map",
  "map": null,
  "metadata": {},
  "sourceType": "module"
}
