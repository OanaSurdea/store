{
  "ast": null,
  "code": "'use strict';\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n * @suppress {globalThis}\n */\n\nconst NEWLINE = '\\n';\nconst IGNORE_FRAMES = {};\nconst creationTrace = '__creationTrace__';\nconst ERROR_TAG = 'STACKTRACE TRACKING';\nconst SEP_TAG = '__SEP_TAG__';\nlet sepTemplate = SEP_TAG + '@[native]';\n\nclass LongStackTrace {\n  constructor() {\n    this.error = getStacktrace();\n    this.timestamp = new Date();\n  }\n\n}\n\nfunction getStacktraceWithUncaughtError() {\n  return new Error(ERROR_TAG);\n}\n\nfunction getStacktraceWithCaughtError() {\n  try {\n    throw getStacktraceWithUncaughtError();\n  } catch (err) {\n    return err;\n  }\n} // Some implementations of exception handling don't create a stack trace if the exception\n// isn't thrown, however it's faster not to actually throw the exception.\n\n\nconst error = getStacktraceWithUncaughtError();\nconst caughtError = getStacktraceWithCaughtError();\nconst getStacktrace = error.stack ? getStacktraceWithUncaughtError : caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError;\n\nfunction getFrames(error) {\n  return error.stack ? error.stack.split(NEWLINE) : [];\n}\n\nfunction addErrorStack(lines, error) {\n  let trace = getFrames(error);\n\n  for (let i = 0; i < trace.length; i++) {\n    const frame = trace[i]; // Filter out the Frames which are part of stack capturing.\n\n    if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n      lines.push(trace[i]);\n    }\n  }\n}\n\nfunction renderLongStackTrace(frames, stack) {\n  const longTrace = [stack ? stack.trim() : ''];\n\n  if (frames) {\n    let timestamp = new Date().getTime();\n\n    for (let i = 0; i < frames.length; i++) {\n      const traceFrames = frames[i];\n      const lastTime = traceFrames.timestamp;\n      let separator = `____________________Elapsed ${timestamp - lastTime.getTime()} ms; At: ${lastTime}`;\n      separator = separator.replace(/[^\\w\\d]/g, '_');\n      longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n      addErrorStack(longTrace, traceFrames.error);\n      timestamp = lastTime.getTime();\n    }\n  }\n\n  return longTrace.join(NEWLINE);\n} // if Error.stackTraceLimit is 0, means stack trace\n// is disabled, so we don't need to generate long stack trace\n// this will improve performance in some test(some test will\n// set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n\n\nfunction stackTracesEnabled() {\n  // Cast through any since this property only exists on Error in the nodejs\n  // typings.\n  return Error.stackTraceLimit > 0;\n}\n\nZone['longStackTraceZoneSpec'] = {\n  name: 'long-stack-trace',\n  longStackTraceLimit: 10,\n  // add a getLongStackTrace method in spec to\n  // handle handled reject promise error.\n  getLongStackTrace: function (error) {\n    if (!error) {\n      return undefined;\n    }\n\n    const trace = error[Zone.__symbol__('currentTaskTrace')];\n\n    if (!trace) {\n      return error.stack;\n    }\n\n    return renderLongStackTrace(trace, error.stack);\n  },\n  onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n    if (stackTracesEnabled()) {\n      const currentTask = Zone.currentTask;\n      let trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n      trace = [new LongStackTrace()].concat(trace);\n\n      if (trace.length > this.longStackTraceLimit) {\n        trace.length = this.longStackTraceLimit;\n      }\n\n      if (!task.data) task.data = {};\n\n      if (task.type === 'eventTask') {\n        // Fix issue https://github.com/angular/zone.js/issues/1195,\n        // For event task of browser, by default, all task will share a\n        // singleton instance of data object, we should create a new one here\n        // The cast to `any` is required to workaround a closure bug which wrongly applies\n        // URL sanitization rules to .data access.\n        task.data = Object.assign({}, task.data);\n      }\n\n      task.data[creationTrace] = trace;\n    }\n\n    return parentZoneDelegate.scheduleTask(targetZone, task);\n  },\n  onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n    if (stackTracesEnabled()) {\n      const parentTask = Zone.currentTask || error.task;\n\n      if (error instanceof Error && parentTask) {\n        const longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n\n        try {\n          error.stack = error.longStack = longStack;\n        } catch (err) {}\n      }\n    }\n\n    return parentZoneDelegate.handleError(targetZone, error);\n  }\n};\n\nfunction captureStackTraces(stackTraces, count) {\n  if (count > 0) {\n    stackTraces.push(getFrames(new LongStackTrace().error));\n    captureStackTraces(stackTraces, count - 1);\n  }\n}\n\nfunction computeIgnoreFrames() {\n  if (!stackTracesEnabled()) {\n    return;\n  }\n\n  const frames = [];\n  captureStackTraces(frames, 2);\n  const frames1 = frames[0];\n  const frames2 = frames[1];\n\n  for (let i = 0; i < frames1.length; i++) {\n    const frame1 = frames1[i];\n\n    if (frame1.indexOf(ERROR_TAG) == -1) {\n      let match = frame1.match(/^\\s*at\\s+/);\n\n      if (match) {\n        sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n        break;\n      }\n    }\n  }\n\n  for (let i = 0; i < frames1.length; i++) {\n    const frame1 = frames1[i];\n    const frame2 = frames2[i];\n\n    if (frame1 === frame2) {\n      IGNORE_FRAMES[frame1] = true;\n    } else {\n      break;\n    }\n  }\n}\n\ncomputeIgnoreFrames();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nclass ProxyZoneSpec {\n  constructor(defaultSpecDelegate = null) {\n    this.defaultSpecDelegate = defaultSpecDelegate;\n    this.name = 'ProxyZone';\n    this._delegateSpec = null;\n    this.properties = {\n      'ProxyZoneSpec': this\n    };\n    this.propertyKeys = null;\n    this.lastTaskState = null;\n    this.isNeedToTriggerHasTask = false;\n    this.tasks = [];\n    this.setDelegate(defaultSpecDelegate);\n  }\n\n  static get() {\n    return Zone.current.get('ProxyZoneSpec');\n  }\n\n  static isLoaded() {\n    return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n  }\n\n  static assertPresent() {\n    if (!ProxyZoneSpec.isLoaded()) {\n      throw new Error(`Expected to be running in 'ProxyZone', but it was not found.`);\n    }\n\n    return ProxyZoneSpec.get();\n  }\n\n  setDelegate(delegateSpec) {\n    const isNewDelegate = this._delegateSpec !== delegateSpec;\n    this._delegateSpec = delegateSpec;\n    this.propertyKeys && this.propertyKeys.forEach(key => delete this.properties[key]);\n    this.propertyKeys = null;\n\n    if (delegateSpec && delegateSpec.properties) {\n      this.propertyKeys = Object.keys(delegateSpec.properties);\n      this.propertyKeys.forEach(k => this.properties[k] = delegateSpec.properties[k]);\n    } // if a new delegateSpec was set, check if we need to trigger hasTask\n\n\n    if (isNewDelegate && this.lastTaskState && (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n      this.isNeedToTriggerHasTask = true;\n    }\n  }\n\n  getDelegate() {\n    return this._delegateSpec;\n  }\n\n  resetDelegate() {\n    const delegateSpec = this.getDelegate();\n    this.setDelegate(this.defaultSpecDelegate);\n  }\n\n  tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone) {\n    if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n      // last delegateSpec has microTask or macroTask\n      // should call onHasTask in current delegateSpec\n      this.isNeedToTriggerHasTask = false;\n      this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n    }\n  }\n\n  removeFromTasks(task) {\n    if (!this.tasks) {\n      return;\n    }\n\n    for (let i = 0; i < this.tasks.length; i++) {\n      if (this.tasks[i] === task) {\n        this.tasks.splice(i, 1);\n        return;\n      }\n    }\n  }\n\n  getAndClearPendingTasksInfo() {\n    if (this.tasks.length === 0) {\n      return '';\n    }\n\n    const taskInfo = this.tasks.map(task => {\n      const dataInfo = task.data && Object.keys(task.data).map(key => {\n        return key + ':' + task.data[key];\n      }).join(',');\n      return `type: ${task.type}, source: ${task.source}, args: {${dataInfo}}`;\n    });\n    const pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']'; // clear tasks\n\n    this.tasks = [];\n    return pendingTasksInfo;\n  }\n\n  onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n    if (this._delegateSpec && this._delegateSpec.onFork) {\n      return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n    } else {\n      return parentZoneDelegate.fork(targetZone, zoneSpec);\n    }\n  }\n\n  onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source) {\n    if (this._delegateSpec && this._delegateSpec.onIntercept) {\n      return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n    } else {\n      return parentZoneDelegate.intercept(targetZone, delegate, source);\n    }\n  }\n\n  onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n    this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n    if (this._delegateSpec && this._delegateSpec.onInvoke) {\n      return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n    } else {\n      return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n    }\n  }\n\n  onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n    if (this._delegateSpec && this._delegateSpec.onHandleError) {\n      return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n    } else {\n      return parentZoneDelegate.handleError(targetZone, error);\n    }\n  }\n\n  onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n    if (task.type !== 'eventTask') {\n      this.tasks.push(task);\n    }\n\n    if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n      return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n    } else {\n      return parentZoneDelegate.scheduleTask(targetZone, task);\n    }\n  }\n\n  onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n    if (task.type !== 'eventTask') {\n      this.removeFromTasks(task);\n    }\n\n    this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n    if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n      return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n    } else {\n      return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n    }\n  }\n\n  onCancelTask(parentZoneDelegate, currentZone, targetZone, task) {\n    if (task.type !== 'eventTask') {\n      this.removeFromTasks(task);\n    }\n\n    this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n    if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n      return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n    } else {\n      return parentZoneDelegate.cancelTask(targetZone, task);\n    }\n  }\n\n  onHasTask(delegate, current, target, hasTaskState) {\n    this.lastTaskState = hasTaskState;\n\n    if (this._delegateSpec && this._delegateSpec.onHasTask) {\n      this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n    } else {\n      delegate.hasTask(target, hasTaskState);\n    }\n  }\n\n} // Export the class so that new instances can be created with proper\n// constructor params.\n\n\nZone['ProxyZoneSpec'] = ProxyZoneSpec;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nclass SyncTestZoneSpec {\n  constructor(namePrefix) {\n    this.runZone = Zone.current;\n    this.name = 'syncTestZone for ' + namePrefix;\n  }\n\n  onScheduleTask(delegate, current, target, task) {\n    switch (task.type) {\n      case 'microTask':\n      case 'macroTask':\n        throw new Error(`Cannot call ${task.source} from within a sync test.`);\n\n      case 'eventTask':\n        task = delegate.scheduleTask(target, task);\n        break;\n    }\n\n    return task;\n  }\n\n} // Export the class so that new instances can be created with proper\n// constructor params.\n\n\nZone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nZone.__load_patch('jasmine', (global, Zone, api) => {\n  const __extends = function (d, b) {\n    for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  }; // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n  // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n\n\n  if (!Zone) throw new Error('Missing: zone.js');\n\n  if (typeof jest !== 'undefined') {\n    // return if jasmine is a light implementation inside jest\n    // in this case, we are running inside jest not jasmine\n    return;\n  }\n\n  if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n    return;\n  }\n\n  jasmine['__zone_patch__'] = true;\n  const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n  const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n  if (!SyncTestZoneSpec) throw new Error('Missing: SyncTestZoneSpec');\n  if (!ProxyZoneSpec) throw new Error('Missing: ProxyZoneSpec');\n  const ambientZone = Zone.current; // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n  // error if any asynchronous operations are attempted inside of a `describe` but outside of\n  // a `beforeEach` or `it`.\n\n  const syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n  const symbol = Zone.__symbol__; // whether patch jasmine clock when in fakeAsync\n\n  const disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true; // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n  // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n  // automatically disable the auto jump into fakeAsync feature\n\n  const enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global[symbol('fakeAsyncPatchLock')] === true || global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true);\n  const ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n\n  if (!ignoreUnhandledRejection) {\n    const globalErrors = jasmine.GlobalErrors;\n\n    if (globalErrors && !jasmine[symbol('GlobalErrors')]) {\n      jasmine[symbol('GlobalErrors')] = globalErrors;\n\n      jasmine.GlobalErrors = function () {\n        const instance = new globalErrors();\n        const originalInstall = instance.install;\n\n        if (originalInstall && !instance[symbol('install')]) {\n          instance[symbol('install')] = originalInstall;\n\n          instance.install = function () {\n            const originalHandlers = process.listeners('unhandledRejection');\n            const r = originalInstall.apply(this, arguments);\n            process.removeAllListeners('unhandledRejection');\n\n            if (originalHandlers) {\n              originalHandlers.forEach(h => process.on('unhandledRejection', h));\n            }\n\n            return r;\n          };\n        }\n\n        return instance;\n      };\n    }\n  } // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n\n\n  const jasmineEnv = jasmine.getEnv();\n  ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {\n    let originalJasmineFn = jasmineEnv[methodName];\n\n    jasmineEnv[methodName] = function (description, specDefinitions) {\n      return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n    };\n  });\n  ['it', 'xit', 'fit'].forEach(methodName => {\n    let originalJasmineFn = jasmineEnv[methodName];\n    jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n    jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n      arguments[1] = wrapTestInZone(specDefinitions);\n      return originalJasmineFn.apply(this, arguments);\n    };\n  });\n  ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {\n    let originalJasmineFn = jasmineEnv[methodName];\n    jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n    jasmineEnv[methodName] = function (specDefinitions, timeout) {\n      arguments[0] = wrapTestInZone(specDefinitions);\n      return originalJasmineFn.apply(this, arguments);\n    };\n  });\n\n  if (!disablePatchingJasmineClock) {\n    // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n    // they can work properly in FakeAsyncTest\n    const originalClockFn = jasmine[symbol('clock')] = jasmine['clock'];\n\n    jasmine['clock'] = function () {\n      const clock = originalClockFn.apply(this, arguments);\n\n      if (!clock[symbol('patched')]) {\n        clock[symbol('patched')] = symbol('patched');\n        const originalTick = clock[symbol('tick')] = clock.tick;\n\n        clock.tick = function () {\n          const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n          }\n\n          return originalTick.apply(this, arguments);\n        };\n\n        const originalMockDate = clock[symbol('mockDate')] = clock.mockDate;\n\n        clock.mockDate = function () {\n          const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            const dateTime = arguments.length > 0 ? arguments[0] : new Date();\n            return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] : arguments);\n          }\n\n          return originalMockDate.apply(this, arguments);\n        }; // for auto go into fakeAsync feature, we need the flag to enable it\n\n\n        if (enableAutoFakeAsyncWhenClockPatched) {\n          ['install', 'uninstall'].forEach(methodName => {\n            const originalClockFn = clock[symbol(methodName)] = clock[methodName];\n\n            clock[methodName] = function () {\n              const FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n\n              if (FakeAsyncTestZoneSpec) {\n                jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                return;\n              }\n\n              return originalClockFn.apply(this, arguments);\n            };\n          });\n        }\n      }\n\n      return clock;\n    };\n  } // monkey patch createSpyObj to make properties enumerable to true\n\n\n  if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n    const originalCreateSpyObj = jasmine.createSpyObj;\n    jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj;\n\n    jasmine.createSpyObj = function () {\n      const args = Array.prototype.slice.call(arguments);\n      const propertyNames = args.length >= 3 ? args[2] : null;\n      let spyObj;\n\n      if (propertyNames) {\n        const defineProperty = Object.defineProperty;\n\n        Object.defineProperty = function (obj, p, attributes) {\n          return defineProperty.call(this, obj, p, Object.assign(Object.assign({}, attributes), {\n            configurable: true,\n            enumerable: true\n          }));\n        };\n\n        try {\n          spyObj = originalCreateSpyObj.apply(this, args);\n        } finally {\n          Object.defineProperty = defineProperty;\n        }\n      } else {\n        spyObj = originalCreateSpyObj.apply(this, args);\n      }\n\n      return spyObj;\n    };\n  }\n  /**\n   * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n   * synchronous-only zone.\n   */\n\n\n  function wrapDescribeInZone(describeBody) {\n    return function () {\n      return syncZone.run(describeBody, this, arguments);\n    };\n  }\n\n  function runInTestZone(testBody, applyThis, queueRunner, done) {\n    const isClockInstalled = !!jasmine[symbol('clockInstalled')];\n    const testProxyZoneSpec = queueRunner.testProxyZoneSpec;\n    const testProxyZone = queueRunner.testProxyZone;\n\n    if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n      // auto run a fakeAsync\n      const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n      if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n        testBody = fakeAsyncModule.fakeAsync(testBody);\n      }\n    }\n\n    if (done) {\n      return testProxyZone.run(testBody, applyThis, [done]);\n    } else {\n      return testProxyZone.run(testBody, applyThis);\n    }\n  }\n  /**\n   * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n   * execute in a ProxyZone zone.\n   * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n   */\n\n\n  function wrapTestInZone(testBody) {\n    // The `done` callback is only passed through if the function expects at least one argument.\n    // Note we have to make a function with correct number of arguments, otherwise jasmine will\n    // think that all functions are sync or async.\n    return testBody && (testBody.length ? function (done) {\n      return runInTestZone(testBody, this, this.queueRunner, done);\n    } : function () {\n      return runInTestZone(testBody, this, this.queueRunner);\n    });\n  }\n\n  const QueueRunner = jasmine.QueueRunner;\n\n  jasmine.QueueRunner = function (_super) {\n    __extends(ZoneQueueRunner, _super);\n\n    function ZoneQueueRunner(attrs) {\n      if (attrs.onComplete) {\n        attrs.onComplete = (fn => () => {\n          // All functions are done, clear the test zone.\n          this.testProxyZone = null;\n          this.testProxyZoneSpec = null;\n          ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n        })(attrs.onComplete);\n      }\n\n      const nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n\n      const nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n\n      if (nativeSetTimeout) {\n        // should run setTimeout inside jasmine outside of zone\n        attrs.timeout = {\n          setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n          clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n        };\n      } // create a userContext to hold the queueRunner itself\n      // so we can access the testProxy in it/xit/beforeEach ...\n\n\n      if (jasmine.UserContext) {\n        if (!attrs.userContext) {\n          attrs.userContext = new jasmine.UserContext();\n        }\n\n        attrs.userContext.queueRunner = this;\n      } else {\n        if (!attrs.userContext) {\n          attrs.userContext = {};\n        }\n\n        attrs.userContext.queueRunner = this;\n      } // patch attrs.onException\n\n\n      const onException = attrs.onException;\n\n      attrs.onException = function (error) {\n        if (error && error.message === 'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n          // jasmine timeout, we can make the error message more\n          // reasonable to tell what tasks are pending\n          const proxyZoneSpec = this && this.testProxyZoneSpec;\n\n          if (proxyZoneSpec) {\n            const pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n\n            try {\n              // try catch here in case error.message is not writable\n              error.message += pendingTasksInfo;\n            } catch (err) {}\n          }\n        }\n\n        if (onException) {\n          onException.call(this, error);\n        }\n      };\n\n      _super.call(this, attrs);\n    }\n\n    ZoneQueueRunner.prototype.execute = function () {\n      let zone = Zone.current;\n      let isChildOfAmbientZone = false;\n\n      while (zone) {\n        if (zone === ambientZone) {\n          isChildOfAmbientZone = true;\n          break;\n        }\n\n        zone = zone.parent;\n      }\n\n      if (!isChildOfAmbientZone) throw new Error('Unexpected Zone: ' + Zone.current.name); // This is the zone which will be used for running individual tests.\n      // It will be a proxy zone, so that the tests function can retroactively install\n      // different zones.\n      // Example:\n      //   - In beforeEach() do childZone = Zone.current.fork(...);\n      //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n      //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n      //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n      //     fakeAsync behavior to the childZone.\n\n      this.testProxyZoneSpec = new ProxyZoneSpec();\n      this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n\n      if (!Zone.currentTask) {\n        // if we are not running in a task then if someone would register a\n        // element.addEventListener and then calling element.click() the\n        // addEventListener callback would think that it is the top most task and would\n        // drain the microtask queue on element.click() which would be incorrect.\n        // For this reason we always force a task when running jasmine tests.\n        Zone.current.scheduleMicroTask('jasmine.execute().forceTask', () => QueueRunner.prototype.execute.call(this));\n      } else {\n        _super.prototype.execute.call(this);\n      }\n    };\n\n    return ZoneQueueRunner;\n  }(QueueRunner);\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nZone.__load_patch('jest', (context, Zone, api) => {\n  if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n    return;\n  }\n\n  jest['__zone_patch__'] = true;\n  const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n  const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n  if (!ProxyZoneSpec) {\n    throw new Error('Missing ProxyZoneSpec');\n  }\n\n  const rootZone = Zone.current;\n  const syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n  const proxyZoneSpec = new ProxyZoneSpec();\n  const proxyZone = rootZone.fork(proxyZoneSpec);\n\n  function wrapDescribeFactoryInZone(originalJestFn) {\n    return function (...tableArgs) {\n      const originalDescribeFn = originalJestFn.apply(this, tableArgs);\n      return function (...args) {\n        args[1] = wrapDescribeInZone(args[1]);\n        return originalDescribeFn.apply(this, args);\n      };\n    };\n  }\n\n  function wrapTestFactoryInZone(originalJestFn) {\n    return function (...tableArgs) {\n      return function (...args) {\n        args[1] = wrapTestInZone(args[1]);\n        return originalJestFn.apply(this, tableArgs).apply(this, args);\n      };\n    };\n  }\n  /**\n   * Gets a function wrapping the body of a jest `describe` block to execute in a\n   * synchronous-only zone.\n   */\n\n\n  function wrapDescribeInZone(describeBody) {\n    return function (...args) {\n      return syncZone.run(describeBody, this, args);\n    };\n  }\n  /**\n   * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n   * execute in a ProxyZone zone.\n   * This will run in the `proxyZone`.\n   */\n\n\n  function wrapTestInZone(testBody, isTestFunc = false) {\n    if (typeof testBody !== 'function') {\n      return testBody;\n    }\n\n    const wrappedFunc = function () {\n      if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody && !testBody.isFakeAsync) {\n        // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n        const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n          testBody = fakeAsyncModule.fakeAsync(testBody);\n        }\n      }\n\n      proxyZoneSpec.isTestFunc = isTestFunc;\n      return proxyZone.run(testBody, null, arguments);\n    }; // Update the length of wrappedFunc to be the same as the length of the testBody\n    // So jest core can handle whether the test function has `done()` or not correctly\n\n\n    Object.defineProperty(wrappedFunc, 'length', {\n      configurable: true,\n      writable: true,\n      enumerable: false\n    });\n    wrappedFunc.length = testBody.length;\n    return wrappedFunc;\n  }\n\n  ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {\n    let originalJestFn = context[methodName];\n\n    if (context[Zone.__symbol__(methodName)]) {\n      return;\n    }\n\n    context[Zone.__symbol__(methodName)] = originalJestFn;\n\n    context[methodName] = function (...args) {\n      args[1] = wrapDescribeInZone(args[1]);\n      return originalJestFn.apply(this, args);\n    };\n\n    context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n  });\n  context.describe.only = context.fdescribe;\n  context.describe.skip = context.xdescribe;\n  ['it', 'xit', 'fit', 'test', 'xtest'].forEach(methodName => {\n    let originalJestFn = context[methodName];\n\n    if (context[Zone.__symbol__(methodName)]) {\n      return;\n    }\n\n    context[Zone.__symbol__(methodName)] = originalJestFn;\n\n    context[methodName] = function (...args) {\n      args[1] = wrapTestInZone(args[1], true);\n      return originalJestFn.apply(this, args);\n    };\n\n    context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n    context[methodName].todo = originalJestFn.todo;\n  });\n  context.it.only = context.fit;\n  context.it.skip = context.xit;\n  context.test.only = context.fit;\n  context.test.skip = context.xit;\n  ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {\n    let originalJestFn = context[methodName];\n\n    if (context[Zone.__symbol__(methodName)]) {\n      return;\n    }\n\n    context[Zone.__symbol__(methodName)] = originalJestFn;\n\n    context[methodName] = function (...args) {\n      args[0] = wrapTestInZone(args[0]);\n      return originalJestFn.apply(this, args);\n    };\n  });\n\n  Zone.patchJestObject = function patchJestObject(Timer, isModern = false) {\n    // check whether currently the test is inside fakeAsync()\n    function isPatchingFakeTimer() {\n      const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n      return !!fakeAsyncZoneSpec;\n    } // check whether the current function is inside `test/it` or other methods\n    // such as `describe/beforeEach`\n\n\n    function isInTestFunc() {\n      const proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n      return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n    }\n\n    if (Timer[api.symbol('fakeTimers')]) {\n      return;\n    }\n\n    Timer[api.symbol('fakeTimers')] = true; // patch jest fakeTimer internal method to make sure no console.warn print out\n\n    api.patchMethod(Timer, '_checkFakeTimers', delegate => {\n      return function (self, args) {\n        if (isPatchingFakeTimer()) {\n          return true;\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n\n    api.patchMethod(Timer, 'useFakeTimers', delegate => {\n      return function (self, args) {\n        Zone[api.symbol('useFakeTimersCalled')] = true;\n\n        if (isModern || isInTestFunc()) {\n          return delegate.apply(self, args);\n        }\n\n        return self;\n      };\n    }); // patch useRealTimers(), unset useFakeTimers flag\n\n    api.patchMethod(Timer, 'useRealTimers', delegate => {\n      return function (self, args) {\n        Zone[api.symbol('useFakeTimersCalled')] = false;\n\n        if (isModern || isInTestFunc()) {\n          return delegate.apply(self, args);\n        }\n\n        return self;\n      };\n    }); // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'setSystemTime', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n          fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'getRealSystemTime', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n          return fakeAsyncZoneSpec.getRealSystemTime();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch runAllTicks(), run all microTasks inside fakeAsync\n\n    api.patchMethod(Timer, 'runAllTicks', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.flushMicrotasks();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch runAllTimers(), run all macroTasks inside fakeAsync\n\n    api.patchMethod(Timer, 'runAllTimers', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.flush(100, true);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'advanceTimersByTime', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.tick(args[0]);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'runOnlyPendingTimers', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.flushOnlyPendingTimers();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'advanceTimersToNextTimer', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.tickToNext(args[0]);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'clearAllTimers', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.removeAllTimers();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'getTimerCount', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          return fakeAsyncZoneSpec.getTimerCount();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    });\n  };\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nZone.__load_patch('mocha', (global, Zone) => {\n  const Mocha = global.Mocha;\n\n  if (typeof Mocha === 'undefined') {\n    // return if Mocha is not available, because now zone-testing\n    // will load mocha patch with jasmine/jest patch\n    return;\n  }\n\n  if (typeof Zone === 'undefined') {\n    throw new Error('Missing Zone.js');\n  }\n\n  const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n  const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n  if (!ProxyZoneSpec) {\n    throw new Error('Missing ProxyZoneSpec');\n  }\n\n  if (Mocha['__zone_patch__']) {\n    throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n  }\n\n  Mocha['__zone_patch__'] = true;\n  const rootZone = Zone.current;\n  const syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n  let testZone = null;\n  const suiteZone = rootZone.fork(new ProxyZoneSpec());\n  const mochaOriginal = {\n    after: Mocha.after,\n    afterEach: Mocha.afterEach,\n    before: Mocha.before,\n    beforeEach: Mocha.beforeEach,\n    describe: Mocha.describe,\n    it: Mocha.it\n  };\n\n  function modifyArguments(args, syncTest, asyncTest) {\n    for (let i = 0; i < args.length; i++) {\n      let arg = args[i];\n\n      if (typeof arg === 'function') {\n        // The `done` callback is only passed through if the function expects at\n        // least one argument.\n        // Note we have to make a function with correct number of arguments,\n        // otherwise mocha will\n        // think that all functions are sync or async.\n        args[i] = arg.length === 0 ? syncTest(arg) : asyncTest(arg); // Mocha uses toString to view the test body in the result list, make sure we return the\n        // correct function body\n\n        args[i].toString = function () {\n          return arg.toString();\n        };\n      }\n    }\n\n    return args;\n  }\n\n  function wrapDescribeInZone(args) {\n    const syncTest = function (fn) {\n      return function () {\n        return syncZone.run(fn, this, arguments);\n      };\n    };\n\n    return modifyArguments(args, syncTest);\n  }\n\n  function wrapTestInZone(args) {\n    const asyncTest = function (fn) {\n      return function (done) {\n        return testZone.run(fn, this, [done]);\n      };\n    };\n\n    const syncTest = function (fn) {\n      return function () {\n        return testZone.run(fn, this);\n      };\n    };\n\n    return modifyArguments(args, syncTest, asyncTest);\n  }\n\n  function wrapSuiteInZone(args) {\n    const asyncTest = function (fn) {\n      return function (done) {\n        return suiteZone.run(fn, this, [done]);\n      };\n    };\n\n    const syncTest = function (fn) {\n      return function () {\n        return suiteZone.run(fn, this);\n      };\n    };\n\n    return modifyArguments(args, syncTest, asyncTest);\n  }\n\n  global.describe = global.suite = Mocha.describe = function () {\n    return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n  };\n\n  global.xdescribe = global.suite.skip = Mocha.describe.skip = function () {\n    return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n  };\n\n  global.describe.only = global.suite.only = Mocha.describe.only = function () {\n    return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n  };\n\n  global.it = global.specify = global.test = Mocha.it = function () {\n    return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n  };\n\n  global.xit = global.xspecify = Mocha.it.skip = function () {\n    return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n  };\n\n  global.it.only = global.test.only = Mocha.it.only = function () {\n    return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n  };\n\n  global.after = global.suiteTeardown = Mocha.after = function () {\n    return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n  };\n\n  global.afterEach = global.teardown = Mocha.afterEach = function () {\n    return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n  };\n\n  global.before = global.suiteSetup = Mocha.before = function () {\n    return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n  };\n\n  global.beforeEach = global.setup = Mocha.beforeEach = function () {\n    return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n  };\n\n  ((originalRunTest, originalRun) => {\n    Mocha.Runner.prototype.runTest = function (fn) {\n      Zone.current.scheduleMicroTask('mocha.forceTask', () => {\n        originalRunTest.call(this, fn);\n      });\n    };\n\n    Mocha.Runner.prototype.run = function (fn) {\n      this.on('test', e => {\n        testZone = rootZone.fork(new ProxyZoneSpec());\n      });\n      this.on('fail', (test, err) => {\n        const proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n\n        if (proxyZoneSpec && err) {\n          try {\n            // try catch here in case err.message is not writable\n            err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n          } catch (error) {}\n        }\n      });\n      return originalRun.call(this, fn);\n    };\n  })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n(function (_global) {\n  class AsyncTestZoneSpec {\n    constructor(finishCallback, failCallback, namePrefix) {\n      this.finishCallback = finishCallback;\n      this.failCallback = failCallback;\n      this._pendingMicroTasks = false;\n      this._pendingMacroTasks = false;\n      this._alreadyErrored = false;\n      this._isSync = false;\n      this.runZone = Zone.current;\n      this.unresolvedChainedPromiseCount = 0;\n      this.supportWaitUnresolvedChainedPromise = false;\n      this.name = 'asyncTestZone for ' + namePrefix;\n      this.properties = {\n        'AsyncTestZoneSpec': this\n      };\n      this.supportWaitUnresolvedChainedPromise = _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n    }\n\n    isUnresolvedChainedPromisePending() {\n      return this.unresolvedChainedPromiseCount > 0;\n    }\n\n    _finishCallbackIfDone() {\n      if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {\n        // We do this because we would like to catch unhandled rejected promises.\n        this.runZone.run(() => {\n          setTimeout(() => {\n            if (!this._alreadyErrored && !(this._pendingMicroTasks || this._pendingMacroTasks)) {\n              this.finishCallback();\n            }\n          }, 0);\n        });\n      }\n    }\n\n    patchPromiseForTest() {\n      if (!this.supportWaitUnresolvedChainedPromise) {\n        return;\n      }\n\n      const patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n\n      if (patchPromiseForTest) {\n        patchPromiseForTest();\n      }\n    }\n\n    unPatchPromiseForTest() {\n      if (!this.supportWaitUnresolvedChainedPromise) {\n        return;\n      }\n\n      const unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n\n      if (unPatchPromiseForTest) {\n        unPatchPromiseForTest();\n      }\n    }\n\n    onScheduleTask(delegate, current, target, task) {\n      if (task.type !== 'eventTask') {\n        this._isSync = false;\n      }\n\n      if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n        // check whether the promise is a chained promise\n        if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n          // chained promise is being scheduled\n          this.unresolvedChainedPromiseCount--;\n        }\n      }\n\n      return delegate.scheduleTask(target, task);\n    }\n\n    onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {\n      if (task.type !== 'eventTask') {\n        this._isSync = false;\n      }\n\n      return delegate.invokeTask(target, task, applyThis, applyArgs);\n    }\n\n    onCancelTask(delegate, current, target, task) {\n      if (task.type !== 'eventTask') {\n        this._isSync = false;\n      }\n\n      return delegate.cancelTask(target, task);\n    } // Note - we need to use onInvoke at the moment to call finish when a test is\n    // fully synchronous. TODO(juliemr): remove this when the logic for\n    // onHasTask changes and it calls whenever the task queues are dirty.\n    // updated by(JiaLiPassion), only call finish callback when no task\n    // was scheduled/invoked/canceled.\n\n\n    onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n      try {\n        this._isSync = true;\n        return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n      } finally {\n        const afterTaskCounts = parentZoneDelegate._taskCounts;\n\n        if (this._isSync) {\n          this._finishCallbackIfDone();\n        }\n      }\n    }\n\n    onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n      // Let the parent try to handle the error.\n      const result = parentZoneDelegate.handleError(targetZone, error);\n\n      if (result) {\n        this.failCallback(error);\n        this._alreadyErrored = true;\n      }\n\n      return false;\n    }\n\n    onHasTask(delegate, current, target, hasTaskState) {\n      delegate.hasTask(target, hasTaskState);\n\n      if (hasTaskState.change == 'microTask') {\n        this._pendingMicroTasks = hasTaskState.microTask;\n\n        this._finishCallbackIfDone();\n      } else if (hasTaskState.change == 'macroTask') {\n        this._pendingMacroTasks = hasTaskState.macroTask;\n\n        this._finishCallbackIfDone();\n      }\n    }\n\n  }\n\n  AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved'); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n  Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n\nZone.__load_patch('asynctest', (global, Zone, api) => {\n  /**\n   * Wraps a test function in an asynchronous test zone. The test will automatically\n   * complete when all asynchronous calls within this zone are done.\n   */\n  Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n    // If we're running using the Jasmine test framework, adapt to call the 'done'\n    // function when asynchronous activity is finished.\n    if (global.jasmine) {\n      // Not using an arrow function to preserve context passed from call site\n      return function (done) {\n        if (!done) {\n          // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n          // fake it here and assume sync.\n          done = function () {};\n\n          done.fail = function (e) {\n            throw e;\n          };\n        }\n\n        runInTestZone(fn, this, done, err => {\n          if (typeof err === 'string') {\n            return done.fail(new Error(err));\n          } else {\n            done.fail(err);\n          }\n        });\n      };\n    } // Otherwise, return a promise which will resolve when asynchronous activity\n    // is finished. This will be correctly consumed by the Mocha framework with\n    // it('...', async(myFn)); or can be used in a custom framework.\n    // Not using an arrow function to preserve context passed from call site\n\n\n    return function () {\n      return new Promise((finishCallback, failCallback) => {\n        runInTestZone(fn, this, finishCallback, failCallback);\n      });\n    };\n  };\n\n  function runInTestZone(fn, context, finishCallback, failCallback) {\n    const currentZone = Zone.current;\n    const AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n\n    if (AsyncTestZoneSpec === undefined) {\n      throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/async-test.js');\n    }\n\n    const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n\n    if (!ProxyZoneSpec) {\n      throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/proxy.js');\n    }\n\n    const proxyZoneSpec = ProxyZoneSpec.get();\n    ProxyZoneSpec.assertPresent(); // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n    // If we do it in ProxyZone then we will get to infinite recursion.\n\n    const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n    const previousDelegate = proxyZoneSpec.getDelegate();\n    proxyZone.parent.run(() => {\n      const testZoneSpec = new AsyncTestZoneSpec(() => {\n        // Need to restore the original zone.\n        if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n          // Only reset the zone spec if it's\n          // sill this one. Otherwise, assume\n          // it's OK.\n          proxyZoneSpec.setDelegate(previousDelegate);\n        }\n\n        testZoneSpec.unPatchPromiseForTest();\n        currentZone.run(() => {\n          finishCallback();\n        });\n      }, error => {\n        // Need to restore the original zone.\n        if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n          // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n          proxyZoneSpec.setDelegate(previousDelegate);\n        }\n\n        testZoneSpec.unPatchPromiseForTest();\n        currentZone.run(() => {\n          failCallback(error);\n        });\n      }, 'test');\n      proxyZoneSpec.setDelegate(testZoneSpec);\n      testZoneSpec.patchPromiseForTest();\n    });\n    return Zone.current.runGuarded(fn, context);\n  }\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n(function (global) {\n  const OriginalDate = global.Date; // Since when we compile this file to `es2015`, and if we define\n  // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n  // there will be an error which is `Cannot assign to read only property 'prototype'`\n  // so we need to use function implementation here.\n\n  function FakeDate() {\n    if (arguments.length === 0) {\n      const d = new OriginalDate();\n      d.setTime(FakeDate.now());\n      return d;\n    } else {\n      const args = Array.prototype.slice.call(arguments);\n      return new OriginalDate(...args);\n    }\n  }\n\n  FakeDate.now = function () {\n    const fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n    if (fakeAsyncTestZoneSpec) {\n      return fakeAsyncTestZoneSpec.getFakeSystemTime();\n    }\n\n    return OriginalDate.now.apply(this, arguments);\n  };\n\n  FakeDate.UTC = OriginalDate.UTC;\n  FakeDate.parse = OriginalDate.parse; // keep a reference for zone patched timer function\n\n  const timers = {\n    setTimeout: global.setTimeout,\n    setInterval: global.setInterval,\n    clearTimeout: global.clearTimeout,\n    clearInterval: global.clearInterval\n  };\n\n  class Scheduler {\n    constructor() {\n      // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n      this._schedulerQueue = []; // Current simulated time in millis.\n\n      this._currentTickTime = 0; // Current fake system base time in millis.\n\n      this._currentFakeBaseSystemTime = OriginalDate.now(); // track requeuePeriodicTimer\n\n      this._currentTickRequeuePeriodicEntries = [];\n    }\n\n    getCurrentTickTime() {\n      return this._currentTickTime;\n    }\n\n    getFakeSystemTime() {\n      return this._currentFakeBaseSystemTime + this._currentTickTime;\n    }\n\n    setFakeBaseSystemTime(fakeBaseSystemTime) {\n      this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n    }\n\n    getRealSystemTime() {\n      return OriginalDate.now();\n    }\n\n    scheduleFunction(cb, delay, options) {\n      options = Object.assign({\n        args: [],\n        isPeriodic: false,\n        isRequestAnimationFrame: false,\n        id: -1,\n        isRequeuePeriodic: false\n      }, options);\n      let currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n      let endTime = this._currentTickTime + delay; // Insert so that scheduler queue remains sorted by end time.\n\n      let newEntry = {\n        endTime: endTime,\n        id: currentId,\n        func: cb,\n        args: options.args,\n        delay: delay,\n        isPeriodic: options.isPeriodic,\n        isRequestAnimationFrame: options.isRequestAnimationFrame\n      };\n\n      if (options.isRequeuePeriodic) {\n        this._currentTickRequeuePeriodicEntries.push(newEntry);\n      }\n\n      let i = 0;\n\n      for (; i < this._schedulerQueue.length; i++) {\n        let currentEntry = this._schedulerQueue[i];\n\n        if (newEntry.endTime < currentEntry.endTime) {\n          break;\n        }\n      }\n\n      this._schedulerQueue.splice(i, 0, newEntry);\n\n      return currentId;\n    }\n\n    removeScheduledFunctionWithId(id) {\n      for (let i = 0; i < this._schedulerQueue.length; i++) {\n        if (this._schedulerQueue[i].id == id) {\n          this._schedulerQueue.splice(i, 1);\n\n          break;\n        }\n      }\n    }\n\n    removeAll() {\n      this._schedulerQueue = [];\n    }\n\n    getTimerCount() {\n      return this._schedulerQueue.length;\n    }\n\n    tickToNext(step = 1, doTick, tickOptions) {\n      if (this._schedulerQueue.length < step) {\n        return;\n      } // Find the last task currently queued in the scheduler queue and tick\n      // till that time.\n\n\n      const startTime = this._currentTickTime;\n      const targetTask = this._schedulerQueue[step - 1];\n      this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n    }\n\n    tick(millis = 0, doTick, tickOptions) {\n      let finalTime = this._currentTickTime + millis;\n      let lastCurrentTime = 0;\n      tickOptions = Object.assign({\n        processNewMacroTasksSynchronously: true\n      }, tickOptions); // we need to copy the schedulerQueue so nested timeout\n      // will not be wrongly called in the current tick\n      // https://github.com/angular/angular/issues/33799\n\n      const schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n\n      if (schedulerQueue.length === 0 && doTick) {\n        doTick(millis);\n        return;\n      }\n\n      while (schedulerQueue.length > 0) {\n        // clear requeueEntries before each loop\n        this._currentTickRequeuePeriodicEntries = [];\n        let current = schedulerQueue[0];\n\n        if (finalTime < current.endTime) {\n          // Done processing the queue since it's sorted by endTime.\n          break;\n        } else {\n          // Time to run scheduled function. Remove it from the head of queue.\n          let current = schedulerQueue.shift();\n\n          if (!tickOptions.processNewMacroTasksSynchronously) {\n            const idx = this._schedulerQueue.indexOf(current);\n\n            if (idx >= 0) {\n              this._schedulerQueue.splice(idx, 1);\n            }\n          }\n\n          lastCurrentTime = this._currentTickTime;\n          this._currentTickTime = current.endTime;\n\n          if (doTick) {\n            doTick(this._currentTickTime - lastCurrentTime);\n          }\n\n          let retval = current.func.apply(global, current.isRequestAnimationFrame ? [this._currentTickTime] : current.args);\n\n          if (!retval) {\n            // Uncaught exception in the current scheduled function. Stop processing the queue.\n            break;\n          } // check is there any requeue periodic entry is added in\n          // current loop, if there is, we need to add to current loop\n\n\n          if (!tickOptions.processNewMacroTasksSynchronously) {\n            this._currentTickRequeuePeriodicEntries.forEach(newEntry => {\n              let i = 0;\n\n              for (; i < schedulerQueue.length; i++) {\n                const currentEntry = schedulerQueue[i];\n\n                if (newEntry.endTime < currentEntry.endTime) {\n                  break;\n                }\n              }\n\n              schedulerQueue.splice(i, 0, newEntry);\n            });\n          }\n        }\n      }\n\n      lastCurrentTime = this._currentTickTime;\n      this._currentTickTime = finalTime;\n\n      if (doTick) {\n        doTick(this._currentTickTime - lastCurrentTime);\n      }\n    }\n\n    flushOnlyPendingTimers(doTick) {\n      if (this._schedulerQueue.length === 0) {\n        return 0;\n      } // Find the last task currently queued in the scheduler queue and tick\n      // till that time.\n\n\n      const startTime = this._currentTickTime;\n      const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n      this.tick(lastTask.endTime - startTime, doTick, {\n        processNewMacroTasksSynchronously: false\n      });\n      return this._currentTickTime - startTime;\n    }\n\n    flush(limit = 20, flushPeriodic = false, doTick) {\n      if (flushPeriodic) {\n        return this.flushPeriodic(doTick);\n      } else {\n        return this.flushNonPeriodic(limit, doTick);\n      }\n    }\n\n    flushPeriodic(doTick) {\n      if (this._schedulerQueue.length === 0) {\n        return 0;\n      } // Find the last task currently queued in the scheduler queue and tick\n      // till that time.\n\n\n      const startTime = this._currentTickTime;\n      const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n      this.tick(lastTask.endTime - startTime, doTick);\n      return this._currentTickTime - startTime;\n    }\n\n    flushNonPeriodic(limit, doTick) {\n      const startTime = this._currentTickTime;\n      let lastCurrentTime = 0;\n      let count = 0;\n\n      while (this._schedulerQueue.length > 0) {\n        count++;\n\n        if (count > limit) {\n          throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n        } // flush only non-periodic timers.\n        // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n\n\n        if (this._schedulerQueue.filter(task => !task.isPeriodic && !task.isRequestAnimationFrame).length === 0) {\n          break;\n        }\n\n        const current = this._schedulerQueue.shift();\n\n        lastCurrentTime = this._currentTickTime;\n        this._currentTickTime = current.endTime;\n\n        if (doTick) {\n          // Update any secondary schedulers like Jasmine mock Date.\n          doTick(this._currentTickTime - lastCurrentTime);\n        }\n\n        const retval = current.func.apply(global, current.args);\n\n        if (!retval) {\n          // Uncaught exception in the current scheduled function. Stop processing the queue.\n          break;\n        }\n      }\n\n      return this._currentTickTime - startTime;\n    }\n\n  } // Next scheduler id.\n\n\n  Scheduler.nextId = 1;\n\n  class FakeAsyncTestZoneSpec {\n    constructor(namePrefix, trackPendingRequestAnimationFrame = false, macroTaskOptions) {\n      this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n      this.macroTaskOptions = macroTaskOptions;\n      this._scheduler = new Scheduler();\n      this._microtasks = [];\n      this._lastError = null;\n      this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n      this.pendingPeriodicTimers = [];\n      this.pendingTimers = [];\n      this.patchDateLocked = false;\n      this.properties = {\n        'FakeAsyncTestZoneSpec': this\n      };\n      this.name = 'fakeAsyncTestZone for ' + namePrefix; // in case user can't access the construction of FakeAsyncTestSpec\n      // user can also define macroTaskOptions by define a global variable.\n\n      if (!this.macroTaskOptions) {\n        this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n      }\n    }\n\n    static assertInZone() {\n      if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n        throw new Error('The code should be running in the fakeAsync zone to call this function');\n      }\n    }\n\n    _fnAndFlush(fn, completers) {\n      return (...args) => {\n        fn.apply(global, args);\n\n        if (this._lastError === null) {\n          // Success\n          if (completers.onSuccess != null) {\n            completers.onSuccess.apply(global);\n          } // Flush microtasks only on success.\n\n\n          this.flushMicrotasks();\n        } else {\n          // Failure\n          if (completers.onError != null) {\n            completers.onError.apply(global);\n          }\n        } // Return true if there were no errors, false otherwise.\n\n\n        return this._lastError === null;\n      };\n    }\n\n    static _removeTimer(timers, id) {\n      let index = timers.indexOf(id);\n\n      if (index > -1) {\n        timers.splice(index, 1);\n      }\n    }\n\n    _dequeueTimer(id) {\n      return () => {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n      };\n    }\n\n    _requeuePeriodicTimer(fn, interval, args, id) {\n      return () => {\n        // Requeue the timer callback if it's not been canceled.\n        if (this.pendingPeriodicTimers.indexOf(id) !== -1) {\n          this._scheduler.scheduleFunction(fn, interval, {\n            args,\n            isPeriodic: true,\n            id,\n            isRequeuePeriodic: true\n          });\n        }\n      };\n    }\n\n    _dequeuePeriodicTimer(id) {\n      return () => {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n      };\n    }\n\n    _setTimeout(fn, delay, args, isTimer = true) {\n      let removeTimerFn = this._dequeueTimer(Scheduler.nextId); // Queue the callback and dequeue the timer on success and error.\n\n\n      let cb = this._fnAndFlush(fn, {\n        onSuccess: removeTimerFn,\n        onError: removeTimerFn\n      });\n\n      let id = this._scheduler.scheduleFunction(cb, delay, {\n        args,\n        isRequestAnimationFrame: !isTimer\n      });\n\n      if (isTimer) {\n        this.pendingTimers.push(id);\n      }\n\n      return id;\n    }\n\n    _clearTimeout(id) {\n      FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n\n      this._scheduler.removeScheduledFunctionWithId(id);\n    }\n\n    _setInterval(fn, interval, args) {\n      let id = Scheduler.nextId;\n      let completers = {\n        onSuccess: null,\n        onError: this._dequeuePeriodicTimer(id)\n      };\n\n      let cb = this._fnAndFlush(fn, completers); // Use the callback created above to requeue on success.\n\n\n      completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id); // Queue the callback and dequeue the periodic timer only on error.\n\n      this._scheduler.scheduleFunction(cb, interval, {\n        args,\n        isPeriodic: true\n      });\n\n      this.pendingPeriodicTimers.push(id);\n      return id;\n    }\n\n    _clearInterval(id) {\n      FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n\n      this._scheduler.removeScheduledFunctionWithId(id);\n    }\n\n    _resetLastErrorAndThrow() {\n      let error = this._lastError || this._uncaughtPromiseErrors[0];\n      this._uncaughtPromiseErrors.length = 0;\n      this._lastError = null;\n      throw error;\n    }\n\n    getCurrentTickTime() {\n      return this._scheduler.getCurrentTickTime();\n    }\n\n    getFakeSystemTime() {\n      return this._scheduler.getFakeSystemTime();\n    }\n\n    setFakeBaseSystemTime(realTime) {\n      this._scheduler.setFakeBaseSystemTime(realTime);\n    }\n\n    getRealSystemTime() {\n      return this._scheduler.getRealSystemTime();\n    }\n\n    static patchDate() {\n      if (!!global[Zone.__symbol__('disableDatePatching')]) {\n        // we don't want to patch global Date\n        // because in some case, global Date\n        // is already being patched, we need to provide\n        // an option to let user still use their\n        // own version of Date.\n        return;\n      }\n\n      if (global['Date'] === FakeDate) {\n        // already patched\n        return;\n      }\n\n      global['Date'] = FakeDate;\n      FakeDate.prototype = OriginalDate.prototype; // try check and reset timers\n      // because jasmine.clock().install() may\n      // have replaced the global timer\n\n      FakeAsyncTestZoneSpec.checkTimerPatch();\n    }\n\n    static resetDate() {\n      if (global['Date'] === FakeDate) {\n        global['Date'] = OriginalDate;\n      }\n    }\n\n    static checkTimerPatch() {\n      if (global.setTimeout !== timers.setTimeout) {\n        global.setTimeout = timers.setTimeout;\n        global.clearTimeout = timers.clearTimeout;\n      }\n\n      if (global.setInterval !== timers.setInterval) {\n        global.setInterval = timers.setInterval;\n        global.clearInterval = timers.clearInterval;\n      }\n    }\n\n    lockDatePatch() {\n      this.patchDateLocked = true;\n      FakeAsyncTestZoneSpec.patchDate();\n    }\n\n    unlockDatePatch() {\n      this.patchDateLocked = false;\n      FakeAsyncTestZoneSpec.resetDate();\n    }\n\n    tickToNext(steps = 1, doTick, tickOptions = {\n      processNewMacroTasksSynchronously: true\n    }) {\n      if (steps <= 0) {\n        return;\n      }\n\n      FakeAsyncTestZoneSpec.assertInZone();\n      this.flushMicrotasks();\n\n      this._scheduler.tickToNext(steps, doTick, tickOptions);\n\n      if (this._lastError !== null) {\n        this._resetLastErrorAndThrow();\n      }\n    }\n\n    tick(millis = 0, doTick, tickOptions = {\n      processNewMacroTasksSynchronously: true\n    }) {\n      FakeAsyncTestZoneSpec.assertInZone();\n      this.flushMicrotasks();\n\n      this._scheduler.tick(millis, doTick, tickOptions);\n\n      if (this._lastError !== null) {\n        this._resetLastErrorAndThrow();\n      }\n    }\n\n    flushMicrotasks() {\n      FakeAsyncTestZoneSpec.assertInZone();\n\n      const flushErrors = () => {\n        if (this._lastError !== null || this._uncaughtPromiseErrors.length) {\n          // If there is an error stop processing the microtask queue and rethrow the error.\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      while (this._microtasks.length > 0) {\n        let microtask = this._microtasks.shift();\n\n        microtask.func.apply(microtask.target, microtask.args);\n      }\n\n      flushErrors();\n    }\n\n    flush(limit, flushPeriodic, doTick) {\n      FakeAsyncTestZoneSpec.assertInZone();\n      this.flushMicrotasks();\n\n      const elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n\n      if (this._lastError !== null) {\n        this._resetLastErrorAndThrow();\n      }\n\n      return elapsed;\n    }\n\n    flushOnlyPendingTimers(doTick) {\n      FakeAsyncTestZoneSpec.assertInZone();\n      this.flushMicrotasks();\n\n      const elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n\n      if (this._lastError !== null) {\n        this._resetLastErrorAndThrow();\n      }\n\n      return elapsed;\n    }\n\n    removeAllTimers() {\n      FakeAsyncTestZoneSpec.assertInZone();\n\n      this._scheduler.removeAll();\n\n      this.pendingPeriodicTimers = [];\n      this.pendingTimers = [];\n    }\n\n    getTimerCount() {\n      return this._scheduler.getTimerCount() + this._microtasks.length;\n    }\n\n    onScheduleTask(delegate, current, target, task) {\n      switch (task.type) {\n        case 'microTask':\n          let args = task.data && task.data.args; // should pass additional arguments to callback if have any\n          // currently we know process.nextTick will have such additional\n          // arguments\n\n          let additionalArgs;\n\n          if (args) {\n            let callbackIndex = task.data.cbIdx;\n\n            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n              additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n            }\n          }\n\n          this._microtasks.push({\n            func: task.invoke,\n            args: additionalArgs,\n            target: task.data && task.data.target\n          });\n\n          break;\n\n        case 'macroTask':\n          switch (task.source) {\n            case 'setTimeout':\n              task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n              break;\n\n            case 'setImmediate':\n              task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n              break;\n\n            case 'setInterval':\n              task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n              break;\n\n            case 'XMLHttpRequest.send':\n              throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n\n            case 'requestAnimationFrame':\n            case 'webkitRequestAnimationFrame':\n            case 'mozRequestAnimationFrame':\n              // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n              // (60 frames per second)\n              task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n              break;\n\n            default:\n              // user can define which macroTask they want to support by passing\n              // macroTaskOptions\n              const macroTaskOption = this.findMacroTaskOption(task);\n\n              if (macroTaskOption) {\n                const args = task.data && task.data['args'];\n                const delay = args && args.length > 1 ? args[1] : 0;\n                let callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args;\n\n                if (!!macroTaskOption.isPeriodic) {\n                  // periodic macroTask, use setInterval to simulate\n                  task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                  task.data.isPeriodic = true;\n                } else {\n                  // not periodic, use setTimeout to simulate\n                  task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                }\n\n                break;\n              }\n\n              throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n          }\n\n          break;\n\n        case 'eventTask':\n          task = delegate.scheduleTask(target, task);\n          break;\n      }\n\n      return task;\n    }\n\n    onCancelTask(delegate, current, target, task) {\n      switch (task.source) {\n        case 'setTimeout':\n        case 'requestAnimationFrame':\n        case 'webkitRequestAnimationFrame':\n        case 'mozRequestAnimationFrame':\n          return this._clearTimeout(task.data['handleId']);\n\n        case 'setInterval':\n          return this._clearInterval(task.data['handleId']);\n\n        default:\n          // user can define which macroTask they want to support by passing\n          // macroTaskOptions\n          const macroTaskOption = this.findMacroTaskOption(task);\n\n          if (macroTaskOption) {\n            const handleId = task.data['handleId'];\n            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n          }\n\n          return delegate.cancelTask(target, task);\n      }\n    }\n\n    onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {\n      try {\n        FakeAsyncTestZoneSpec.patchDate();\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      } finally {\n        if (!this.patchDateLocked) {\n          FakeAsyncTestZoneSpec.resetDate();\n        }\n      }\n    }\n\n    findMacroTaskOption(task) {\n      if (!this.macroTaskOptions) {\n        return null;\n      }\n\n      for (let i = 0; i < this.macroTaskOptions.length; i++) {\n        const macroTaskOption = this.macroTaskOptions[i];\n\n        if (macroTaskOption.source === task.source) {\n          return macroTaskOption;\n        }\n      }\n\n      return null;\n    }\n\n    onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n      this._lastError = error;\n      return false; // Don't propagate error to parent zone.\n    }\n\n  } // Export the class so that new instances can be created with proper\n  // constructor params.\n\n\n  Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n})(typeof window === 'object' && window || typeof self === 'object' && self || global);\n\nZone.__load_patch('fakeasync', (global, Zone, api) => {\n  const FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n\n  function getProxyZoneSpec() {\n    return Zone && Zone['ProxyZoneSpec'];\n  }\n\n  let _fakeAsyncTestZoneSpec = null;\n  /**\n   * Clears out the shared fake async zone for a test.\n   * To be called in a global `beforeEach`.\n   *\n   * @experimental\n   */\n\n  function resetFakeAsyncZone() {\n    if (_fakeAsyncTestZoneSpec) {\n      _fakeAsyncTestZoneSpec.unlockDatePatch();\n    }\n\n    _fakeAsyncTestZoneSpec = null; // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n\n    getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n  }\n  /**\n   * Wraps a function to be executed in the fakeAsync zone:\n   * - microtasks are manually executed by calling `flushMicrotasks()`,\n   * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n   *\n   * If there are any pending timers at the end of the function, an exception will be thrown.\n   *\n   * Can be used to wrap inject() calls.\n   *\n   * ## Example\n   *\n   * {@example core/testing/ts/fake_async.ts region='basic'}\n   *\n   * @param fn\n   * @returns The function wrapped to be executed in the fakeAsync zone\n   *\n   * @experimental\n   */\n\n\n  function fakeAsync(fn) {\n    // Not using an arrow function to preserve context passed from call site\n    const fakeAsyncFn = function (...args) {\n      const ProxyZoneSpec = getProxyZoneSpec();\n\n      if (!ProxyZoneSpec) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/proxy.js');\n      }\n\n      const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n\n      if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n        throw new Error('fakeAsync() calls can not be nested');\n      }\n\n      try {\n        // in case jasmine.clock init a fakeAsyncTestZoneSpec\n        if (!_fakeAsyncTestZoneSpec) {\n          if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n            throw new Error('fakeAsync() calls can not be nested');\n          }\n\n          _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n        }\n\n        let res;\n        const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n        proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n\n        _fakeAsyncTestZoneSpec.lockDatePatch();\n\n        try {\n          res = fn.apply(this, args);\n          flushMicrotasks();\n        } finally {\n          proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n        }\n\n        if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n          throw new Error(`${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` + `periodic timer(s) still in the queue.`);\n        }\n\n        if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n          throw new Error(`${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n        }\n\n        return res;\n      } finally {\n        resetFakeAsyncZone();\n      }\n    };\n\n    fakeAsyncFn.isFakeAsync = true;\n    return fakeAsyncFn;\n  }\n\n  function _getFakeAsyncZoneSpec() {\n    if (_fakeAsyncTestZoneSpec == null) {\n      _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n      if (_fakeAsyncTestZoneSpec == null) {\n        throw new Error('The code should be running in the fakeAsync zone to call this function');\n      }\n    }\n\n    return _fakeAsyncTestZoneSpec;\n  }\n  /**\n   * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n   *\n   * The microtasks queue is drained at the very start of this function and after any timer callback\n   * has been executed.\n   *\n   * ## Example\n   *\n   * {@example core/testing/ts/fake_async.ts region='basic'}\n   *\n   * @experimental\n   */\n\n\n  function tick(millis = 0, ignoreNestedTimeout = false) {\n    _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n  }\n  /**\n   * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n   * draining the macrotask queue until it is empty. The returned value is the milliseconds\n   * of time that would have been elapsed.\n   *\n   * @param maxTurns\n   * @returns The simulated time elapsed, in millis.\n   *\n   * @experimental\n   */\n\n\n  function flush(maxTurns) {\n    return _getFakeAsyncZoneSpec().flush(maxTurns);\n  }\n  /**\n   * Discard all remaining periodic tasks.\n   *\n   * @experimental\n   */\n\n\n  function discardPeriodicTasks() {\n    const zoneSpec = _getFakeAsyncZoneSpec();\n\n    const pendingTimers = zoneSpec.pendingPeriodicTimers;\n    zoneSpec.pendingPeriodicTimers.length = 0;\n  }\n  /**\n   * Flush any pending microtasks.\n   *\n   * @experimental\n   */\n\n\n  function flushMicrotasks() {\n    _getFakeAsyncZoneSpec().flushMicrotasks();\n  }\n\n  Zone[api.symbol('fakeAsyncTest')] = {\n    resetFakeAsyncZone,\n    flushMicrotasks,\n    discardPeriodicTasks,\n    tick,\n    flush,\n    fakeAsync\n  };\n}, true);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Promise for async/fakeAsync zoneSpec test\n * can support async operation which not supported by zone.js\n * such as\n * it ('test jsonp in AsyncZone', async() => {\n *   new Promise(res => {\n *     jsonp(url, (data) => {\n *       // success callback\n *       res(data);\n *     });\n *   }).then((jsonpResult) => {\n *     // get jsonp result.\n *\n *     // user will expect AsyncZoneSpec wait for\n *     // then, but because jsonp is not zone aware\n *     // AsyncZone will finish before then is called.\n *   });\n * });\n */\n\n\nZone.__load_patch('promisefortest', (global, Zone, api) => {\n  const symbolState = api.symbol('state');\n  const UNRESOLVED = null;\n  const symbolParentUnresolved = api.symbol('parentUnresolved'); // patch Promise.prototype.then to keep an internal\n  // number for tracking unresolved chained promise\n  // we will decrease this number when the parent promise\n  // being resolved/rejected and chained promise was\n  // scheduled as a microTask.\n  // so we can know such kind of chained promise still\n  // not resolved in AsyncTestZone\n\n  Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n    let oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n    if (oriThen) {\n      return;\n    }\n\n    oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n\n    Promise.prototype.then = function () {\n      const chained = oriThen.apply(this, arguments);\n\n      if (this[symbolState] === UNRESOLVED) {\n        // parent promise is unresolved.\n        const asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n\n        if (asyncTestZoneSpec) {\n          asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n          chained[symbolParentUnresolved] = true;\n        }\n      }\n\n      return chained;\n    };\n  };\n\n  Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n    // restore origin then\n    const oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n    if (oriThen) {\n      Promise.prototype.then = oriThen;\n      Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n    }\n  };\n});",
  "map": null,
  "metadata": {},
  "sourceType": "script"
}
