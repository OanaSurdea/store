{
  "ast": null,
  "code": "import * as i0 from '@angular/core';\nimport { InjectionToken, NgZone, Injector, Injectable, NgModule } from '@angular/core';\nimport * as i1 from '@ngxs/store';\nimport { Action, Selector, State, Store, NgxsModule } from '@ngxs/store';\nimport { __decorate, __metadata } from 'tslib';\nimport * as i2 from '@angular/router';\nimport { NavigationStart, RoutesRecognized, ResolveEnd, NavigationCancel, NavigationError, NavigationEnd, Router } from '@angular/router';\nimport { Subscription } from 'rxjs';\n/**\n * Public event api of the router\n */\n\nclass Navigate {\n  constructor(path, queryParams, extras) {\n    this.path = path;\n    this.queryParams = queryParams;\n    this.extras = extras;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] Navigate';\n  }\n\n}\n/**\n *\n * Angular Routers internal state events\n *\n */\n\n/**\n * An action dispatched when the router starts the navigation.\n */\n\n\nclass RouterRequest {\n  constructor(routerState, event, trigger = 'none') {\n    this.routerState = routerState;\n    this.event = event;\n    this.trigger = trigger;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterRequest';\n  }\n\n}\n/**\n * An action dispatched when the router navigates.\n */\n\n\nclass RouterNavigation {\n  constructor(routerState, event, trigger = 'none') {\n    this.routerState = routerState;\n    this.event = event;\n    this.trigger = trigger;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterNavigation';\n  }\n\n}\n/**\n * An action dispatched when the router cancel navigation.\n */\n\n\nclass RouterCancel {\n  constructor(routerState, storeState, event, trigger = 'none') {\n    this.routerState = routerState;\n    this.storeState = storeState;\n    this.event = event;\n    this.trigger = trigger;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterCancel';\n  }\n\n}\n/**\n * An action dispatched when the router errors.\n */\n\n\nclass RouterError {\n  constructor(routerState, storeState, event, trigger = 'none') {\n    this.routerState = routerState;\n    this.storeState = storeState;\n    this.event = event;\n    this.trigger = trigger;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterError';\n  }\n\n}\n/**\n * An action dispatched when the `ResolveEnd` event is triggered.\n */\n\n\nclass RouterDataResolved {\n  constructor(routerState, event, trigger = 'none') {\n    this.routerState = routerState;\n    this.event = event;\n    this.trigger = trigger;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterDataResolved';\n  }\n\n}\n/**\n * An action dispatched when the router navigation has been finished successfully.\n */\n\n\nclass RouterNavigated {\n  constructor(routerState, event, trigger = 'none') {\n    this.routerState = routerState;\n    this.event = event;\n    this.trigger = trigger;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterNavigated';\n  }\n\n}\n\nclass RouterStateSerializer {}\n\nclass DefaultRouterStateSerializer {\n  serialize(routerState) {\n    return {\n      root: this.serializeRoute(routerState.root),\n      url: routerState.url\n    };\n  }\n\n  serializeRoute(route) {\n    const children = route.children.map(c => this.serializeRoute(c));\n    return {\n      url: route.url,\n      params: route.params,\n      queryParams: route.queryParams,\n      fragment: route.fragment,\n      data: route.data,\n      outlet: route.outlet,\n      component: null,\n      routeConfig: null,\n      root: null,\n      parent: null,\n      firstChild: children[0],\n      children: children,\n      pathFromRoot: null,\n      paramMap: route.paramMap,\n      queryParamMap: route.queryParamMap,\n      toString: route.toString\n    };\n  }\n\n}\n\nconst USER_OPTIONS = new InjectionToken('USER_OPTIONS', {\n  providedIn: 'root',\n  factory: () => undefined\n});\nconst NGXS_ROUTER_PLUGIN_OPTIONS = new InjectionToken('NGXS_ROUTER_PLUGIN_OPTIONS', {\n  providedIn: 'root',\n  factory: () => ({})\n});\n\nfunction createRouterPluginOptions(options) {\n  return {\n    navigationActionTiming: options && options.navigationActionTiming || 1\n    /* PreActivation */\n\n  };\n}\n\nvar RouterState_1;\nlet RouterState = RouterState_1 = class RouterState {\n  constructor(_store, _router, _serializer, _ngZone, injector) {\n    this._store = _store;\n    this._router = _router;\n    this._serializer = _serializer;\n    this._ngZone = _ngZone;\n    /**\n     * Determines how navigation was performed by the `RouterState` itself\n     * or outside via `new Navigate(...)`\n     */\n\n    this._trigger = 'none';\n    /**\n     * That's the serialized state from the `Router` class\n     */\n\n    this._routerState = null;\n    /**\n     * That's the value of the `RouterState` state\n     */\n\n    this._storeState = null;\n    this._lastEvent = null;\n    this._subscription = new Subscription();\n    this._options = null; // Note: do not use `@Inject` since it fails on lower versions of Angular with Jest\n    // integration, it cannot resolve the token provider.\n\n    this._options = injector.get(NGXS_ROUTER_PLUGIN_OPTIONS, null);\n\n    this._setUpStoreListener();\n\n    this._setUpRouterEventsListener();\n  }\n\n  static state(state) {\n    return state && state.state;\n  }\n\n  static url(state) {\n    return state && state.state && state.state.url;\n  }\n\n  ngOnDestroy() {\n    this._subscription.unsubscribe();\n  }\n\n  navigate(_, action) {\n    return this._ngZone.run(() => this._router.navigate(action.path, Object.assign({\n      queryParams: action.queryParams\n    }, action.extras)));\n  }\n\n  angularRouterAction(ctx, action) {\n    ctx.setState({\n      trigger: action.trigger,\n      state: action.routerState,\n      navigationId: action.event.id\n    });\n  }\n\n  _setUpStoreListener() {\n    const subscription = this._store.select(RouterState_1).subscribe(state => {\n      this._navigateIfNeeded(state);\n    });\n\n    this._subscription.add(subscription);\n  }\n\n  _navigateIfNeeded(routerState) {\n    if (routerState && routerState.trigger === 'devtools') {\n      this._storeState = this._store.selectSnapshot(RouterState_1);\n    }\n\n    const canSkipNavigation = !this._storeState || !this._storeState.state || !routerState || routerState.trigger === 'router' || this._router.url === this._storeState.state.url || this._lastEvent instanceof NavigationStart;\n\n    if (canSkipNavigation) {\n      return;\n    }\n\n    this._storeState = this._store.selectSnapshot(RouterState_1);\n    this._trigger = 'store';\n\n    this._ngZone.run(() => this._router.navigateByUrl(this._storeState.state.url));\n  }\n\n  _setUpRouterEventsListener() {\n    const dispatchRouterNavigationLate = this._options != null && this._options.navigationActionTiming === 2\n    /* PostActivation */\n    ;\n    let lastRoutesRecognized;\n\n    const subscription = this._router.events.subscribe(event => {\n      this._lastEvent = event;\n\n      if (event instanceof NavigationStart) {\n        this._navigationStart(event);\n      } else if (event instanceof RoutesRecognized) {\n        lastRoutesRecognized = event;\n\n        if (!dispatchRouterNavigationLate && this._trigger !== 'store') {\n          this._dispatchRouterNavigation(lastRoutesRecognized);\n        }\n      } else if (event instanceof ResolveEnd) {\n        this._dispatchRouterDataResolved(event);\n      } else if (event instanceof NavigationCancel) {\n        this._dispatchRouterCancel(event);\n\n        this._reset();\n      } else if (event instanceof NavigationError) {\n        this._dispatchRouterError(event);\n\n        this._reset();\n      } else if (event instanceof NavigationEnd) {\n        if (this._trigger !== 'store') {\n          if (dispatchRouterNavigationLate) {\n            this._dispatchRouterNavigation(lastRoutesRecognized);\n          }\n\n          this._dispatchRouterNavigated(event);\n        }\n\n        this._reset();\n      }\n    });\n\n    this._subscription.add(subscription);\n  }\n  /** Reacts to `NavigationStart`. */\n\n\n  _navigationStart(event) {\n    this._routerState = this._serializer.serialize(this._router.routerState.snapshot);\n\n    if (this._trigger !== 'none') {\n      this._storeState = this._store.selectSnapshot(RouterState_1);\n\n      this._dispatchRouterAction(new RouterRequest(this._routerState, event, this._trigger));\n    }\n  }\n  /** Reacts to `ResolveEnd`. */\n\n\n  _dispatchRouterDataResolved(event) {\n    const routerState = this._serializer.serialize(event.state);\n\n    this._dispatchRouterAction(new RouterDataResolved(routerState, event, this._trigger));\n  }\n  /** Reacts to `RoutesRecognized` or `NavigationEnd`, depends on the `navigationActionTiming`. */\n\n\n  _dispatchRouterNavigation(lastRoutesRecognized) {\n    const nextRouterState = this._serializer.serialize(lastRoutesRecognized.state);\n\n    this._dispatchRouterAction(new RouterNavigation(nextRouterState, new RoutesRecognized(lastRoutesRecognized.id, lastRoutesRecognized.url, lastRoutesRecognized.urlAfterRedirects, nextRouterState), this._trigger));\n  }\n  /** Reacts to `NavigationCancel`. */\n\n\n  _dispatchRouterCancel(event) {\n    this._dispatchRouterAction(new RouterCancel(this._routerState, this._storeState, event, this._trigger));\n  }\n  /** Reacts to `NavigationEnd`. */\n\n\n  _dispatchRouterError(event) {\n    this._dispatchRouterAction(new RouterError(this._routerState, this._storeState, new NavigationError(event.id, event.url, `${event}`), this._trigger));\n  }\n  /** Reacts to `NavigationEnd`. */\n\n\n  _dispatchRouterNavigated(event) {\n    const routerState = this._serializer.serialize(this._router.routerState.snapshot);\n\n    this._dispatchRouterAction(new RouterNavigated(routerState, event, this._trigger));\n  }\n\n  _dispatchRouterAction(action) {\n    this._trigger = 'router';\n\n    try {\n      this._store.dispatch(action);\n    } finally {\n      this._trigger = 'none';\n    }\n  }\n\n  _reset() {\n    this._trigger = 'none';\n    this._storeState = null;\n    this._routerState = null;\n  }\n\n};\n/** @nocollapse */\n\nRouterState.ɵfac = function RouterState_Factory(t) {\n  return new (t || RouterState)(i0.ɵɵinject(i1.Store), i0.ɵɵinject(i2.Router), i0.ɵɵinject(RouterStateSerializer), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.Injector));\n};\n/** @nocollapse */\n\n\nRouterState.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RouterState,\n  factory: RouterState.ɵfac\n});\n\n__decorate([Action(Navigate), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, Navigate]), __metadata(\"design:returntype\", void 0)], RouterState.prototype, \"navigate\", null);\n\n__decorate([Action([RouterRequest, RouterNavigation, RouterError, RouterCancel, RouterDataResolved, RouterNavigated]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, Object]), __metadata(\"design:returntype\", void 0)], RouterState.prototype, \"angularRouterAction\", null);\n\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], RouterState, \"state\", null);\n\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Object)], RouterState, \"url\", null);\n\nRouterState = RouterState_1 = __decorate([State({\n  name: 'router',\n  defaults: {\n    state: undefined,\n    navigationId: undefined,\n    trigger: 'none'\n  }\n}), __metadata(\"design:paramtypes\", [Store, Router, RouterStateSerializer, NgZone, Injector])], RouterState);\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RouterState, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.Store\n    }, {\n      type: i2.Router\n    }, {\n      type: RouterStateSerializer\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.Injector\n    }];\n  }, {\n    navigate: [],\n    angularRouterAction: []\n  });\n})();\n\nclass NgxsRouterPluginModule {\n  static forRoot(options) {\n    return {\n      ngModule: NgxsRouterPluginModule,\n      providers: [{\n        provide: USER_OPTIONS,\n        useValue: options\n      }, {\n        provide: NGXS_ROUTER_PLUGIN_OPTIONS,\n        useFactory: createRouterPluginOptions,\n        deps: [USER_OPTIONS]\n      }, {\n        provide: RouterStateSerializer,\n        useClass: DefaultRouterStateSerializer\n      }]\n    };\n  }\n\n}\n/** @nocollapse */\n\n\nNgxsRouterPluginModule.ɵfac = function NgxsRouterPluginModule_Factory(t) {\n  return new (t || NgxsRouterPluginModule)();\n};\n/** @nocollapse */\n\n\nNgxsRouterPluginModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsRouterPluginModule,\n  imports: [i1.ɵNgxsFeatureModule]\n});\n/** @nocollapse */\n\nNgxsRouterPluginModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[NgxsModule.forFeature([RouterState])]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsRouterPluginModule, [{\n    type: NgModule,\n    args: [{\n      imports: [NgxsModule.forFeature([RouterState])]\n    }]\n  }], null, null);\n})();\n/**\n * The public api for consumers of @ngxs/router-plugin\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DefaultRouterStateSerializer, Navigate, NgxsRouterPluginModule, RouterCancel, RouterDataResolved, RouterError, RouterNavigated, RouterNavigation, RouterRequest, RouterState, RouterStateSerializer }; //# sourceMappingURL=ngxs-router-plugin.js.map",
  "map": null,
  "metadata": {},
  "sourceType": "module"
}
