{
  "ast": null,
  "code": "import * as i0 from '@angular/core';\nimport { Injectable, Directive, Input, NgModule } from '@angular/core';\nimport * as i1 from '@ngxs/store';\nimport { getActionTypeFromInstance, setValue, getValue, ofActionDispatched, NGXS_PLUGINS } from '@ngxs/store';\nimport * as i2 from '@angular/forms';\nimport { ReactiveFormsModule } from '@angular/forms';\nimport { Subject } from 'rxjs';\nimport { filter, takeUntil, distinctUntilChanged, debounceTime } from 'rxjs/operators';\n\nclass UpdateFormStatus {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Forms] Update Form Status';\n  }\n\n}\n\nclass UpdateFormValue {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Forms] Update Form Value';\n  }\n\n}\n\nclass UpdateForm {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Forms] Update Form';\n  }\n\n}\n\nclass UpdateFormDirty {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Forms] Update Form Dirty';\n  }\n\n}\n\nclass SetFormDirty {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Forms] Set Form Dirty';\n  }\n\n}\n\nclass SetFormPristine {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Forms] Set Form Pristine';\n  }\n\n}\n\nclass UpdateFormErrors {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Forms] Update Form Errors';\n  }\n\n}\n\nclass SetFormDisabled {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Forms] Set Form Disabled';\n  }\n\n}\n\nclass SetFormEnabled {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Forms] Set Form Enabled';\n  }\n\n}\n\nclass ResetForm {\n  constructor(payload) {\n    this.payload = payload;\n  }\n\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Forms] Reset Form';\n  }\n\n}\n\nclass NgxsFormPlugin {\n  handle(state, event, next) {\n    const type = getActionTypeFromInstance(event);\n    let nextState = state;\n\n    if (type === UpdateFormValue.type || type === UpdateForm.type || type === ResetForm.type) {\n      const {\n        value\n      } = event.payload;\n      const payloadValue = Array.isArray(value) ? value.slice() : isObjectLike(value) ? Object.assign({}, value) : value;\n      const path = this.joinPathWithPropertyPath(event);\n      nextState = setValue(nextState, path, payloadValue);\n    }\n\n    if (type === ResetForm.type) {\n      const model = getValue(nextState, `${event.payload.path}.model`);\n      nextState = setValue(nextState, `${event.payload.path}`, {\n        model: model\n      });\n    }\n\n    if (type === UpdateFormStatus.type || type === UpdateForm.type) {\n      nextState = setValue(nextState, `${event.payload.path}.status`, event.payload.status);\n    }\n\n    if (type === UpdateFormErrors.type || type === UpdateForm.type) {\n      nextState = setValue(nextState, `${event.payload.path}.errors`, Object.assign({}, event.payload.errors));\n    }\n\n    if (type === UpdateFormDirty.type || type === UpdateForm.type) {\n      nextState = setValue(nextState, `${event.payload.path}.dirty`, event.payload.dirty);\n    }\n\n    if (type === SetFormDirty.type) {\n      nextState = setValue(nextState, `${event.payload}.dirty`, true);\n    }\n\n    if (type === SetFormPristine.type) {\n      nextState = setValue(nextState, `${event.payload}.dirty`, false);\n    }\n\n    if (type === SetFormDisabled.type) {\n      nextState = setValue(nextState, `${event.payload}.disabled`, true);\n    }\n\n    if (type === SetFormEnabled.type) {\n      nextState = setValue(nextState, `${event.payload}.disabled`, false);\n    }\n\n    return next(nextState, event);\n  }\n\n  joinPathWithPropertyPath({\n    payload\n  }) {\n    let path = `${payload.path}.model`;\n\n    if (payload.propertyPath) {\n      path += `.${payload.propertyPath}`;\n    }\n\n    return path;\n  }\n\n}\n/** @nocollapse */\n\n\nNgxsFormPlugin.ɵfac = function NgxsFormPlugin_Factory(t) {\n  return new (t || NgxsFormPlugin)();\n};\n/** @nocollapse */\n\n\nNgxsFormPlugin.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxsFormPlugin,\n  factory: NgxsFormPlugin.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsFormPlugin, [{\n    type: Injectable\n  }], null, null);\n})();\n\nfunction isObjectLike(target) {\n  return target !== null && typeof target === 'object';\n}\n\nclass FormDirective {\n  constructor(_actions$, _store, _formGroupDirective, _cd) {\n    this._actions$ = _actions$;\n    this._store = _store;\n    this._formGroupDirective = _formGroupDirective;\n    this._cd = _cd;\n    this.path = null;\n    this._debounce = 100;\n    this._clearDestroy = false;\n    this._updating = false;\n    this._destroy$ = new Subject();\n  }\n\n  set debounce(debounce) {\n    this._debounce = Number(debounce);\n  }\n\n  get debounce() {\n    return this._debounce;\n  }\n\n  set clearDestroy(val) {\n    this._clearDestroy = val != null && `${val}` !== 'false';\n  }\n\n  get clearDestroy() {\n    return this._clearDestroy;\n  }\n\n  ngOnInit() {\n    this._actions$.pipe(ofActionDispatched(ResetForm), filter(action => action.payload.path === this.path), takeUntil(this._destroy$)).subscribe(({\n      payload: {\n        value\n      }\n    }) => {\n      this.form.reset(value);\n      this.updateFormStateWithRawValue(true);\n\n      this._cd.markForCheck();\n    });\n\n    this.getStateStream(`${this.path}.model`).subscribe(model => {\n      if (this._updating || !model) {\n        return;\n      }\n\n      this.form.patchValue(model);\n\n      this._cd.markForCheck();\n    });\n    this.getStateStream(`${this.path}.dirty`).subscribe(dirty => {\n      if (this.form.dirty === dirty || typeof dirty !== 'boolean') {\n        return;\n      }\n\n      if (dirty) {\n        this.form.markAsDirty();\n      } else {\n        this.form.markAsPristine();\n      }\n\n      this._cd.markForCheck();\n    }); // On first state change, sync form model, status and dirty with state\n\n    this._store.selectOnce(state => getValue(state, this.path)).subscribe(() => {\n      this._store.dispatch([new UpdateFormValue({\n        path: this.path,\n        value: this.form.getRawValue()\n      }), new UpdateFormStatus({\n        path: this.path,\n        status: this.form.status\n      }), new UpdateFormDirty({\n        path: this.path,\n        dirty: this.form.dirty\n      })]);\n    });\n\n    this.getStateStream(`${this.path}.disabled`).subscribe(disabled => {\n      if (this.form.disabled === disabled || typeof disabled !== 'boolean') {\n        return;\n      }\n\n      if (disabled) {\n        this.form.disable();\n      } else {\n        this.form.enable();\n      }\n\n      this._cd.markForCheck();\n    });\n\n    this._formGroupDirective.valueChanges.pipe(distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)), this.debounceChange()).subscribe(() => {\n      this.updateFormStateWithRawValue();\n    });\n\n    this._formGroupDirective.statusChanges.pipe(distinctUntilChanged(), this.debounceChange()).subscribe(status => {\n      this._store.dispatch(new UpdateFormStatus({\n        status,\n        path: this.path\n      }));\n    });\n  }\n\n  updateFormStateWithRawValue(withFormStatus) {\n    if (this._updating) return;\n\n    const value = this._formGroupDirective.control.getRawValue();\n\n    const actions = [new UpdateFormValue({\n      path: this.path,\n      value\n    }), new UpdateFormDirty({\n      path: this.path,\n      dirty: this._formGroupDirective.dirty\n    }), new UpdateFormErrors({\n      path: this.path,\n      errors: this._formGroupDirective.errors\n    })];\n\n    if (withFormStatus) {\n      actions.push(new UpdateFormStatus({\n        path: this.path,\n        status: this._formGroupDirective.status\n      }));\n    }\n\n    this._updating = true;\n\n    this._store.dispatch(actions).subscribe({\n      error: () => this._updating = false,\n      complete: () => this._updating = false\n    });\n  }\n\n  ngOnDestroy() {\n    this._destroy$.next();\n\n    if (this.clearDestroy) {\n      this._store.dispatch(new UpdateForm({\n        path: this.path,\n        value: null,\n        dirty: null,\n        status: null,\n        errors: null\n      }));\n    }\n  }\n\n  debounceChange() {\n    const skipDebounceTime = this._formGroupDirective.control.updateOn !== 'change' || this._debounce < 0;\n    return skipDebounceTime ? change => change.pipe(takeUntil(this._destroy$)) : change => change.pipe(debounceTime(this._debounce), takeUntil(this._destroy$));\n  }\n\n  get form() {\n    return this._formGroupDirective.form;\n  }\n\n  getStateStream(path) {\n    return this._store.select(state => getValue(state, path)).pipe(takeUntil(this._destroy$));\n  }\n\n}\n/** @nocollapse */\n\n\nFormDirective.ɵfac = function FormDirective_Factory(t) {\n  return new (t || FormDirective)(i0.ɵɵdirectiveInject(i1.Actions), i0.ɵɵdirectiveInject(i1.Store), i0.ɵɵdirectiveInject(i2.FormGroupDirective), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n};\n/** @nocollapse */\n\n\nFormDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: FormDirective,\n  selectors: [[\"\", \"ngxsForm\", \"\"]],\n  inputs: {\n    path: [\"ngxsForm\", \"path\"],\n    debounce: [\"ngxsFormDebounce\", \"debounce\"],\n    clearDestroy: [\"ngxsFormClearOnDestroy\", \"clearDestroy\"]\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FormDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxsForm]'\n    }]\n  }], function () {\n    return [{\n      type: i1.Actions\n    }, {\n      type: i1.Store\n    }, {\n      type: i2.FormGroupDirective\n    }, {\n      type: i0.ChangeDetectorRef\n    }];\n  }, {\n    path: [{\n      type: Input,\n      args: ['ngxsForm']\n    }],\n    debounce: [{\n      type: Input,\n      args: ['ngxsFormDebounce']\n    }],\n    clearDestroy: [{\n      type: Input,\n      args: ['ngxsFormClearOnDestroy']\n    }]\n  });\n})();\n\nclass NgxsFormPluginModule {\n  static forRoot() {\n    return {\n      ngModule: NgxsFormPluginModule,\n      providers: [{\n        provide: NGXS_PLUGINS,\n        useClass: NgxsFormPlugin,\n        multi: true\n      }]\n    };\n  }\n\n}\n/** @nocollapse */\n\n\nNgxsFormPluginModule.ɵfac = function NgxsFormPluginModule_Factory(t) {\n  return new (t || NgxsFormPluginModule)();\n};\n/** @nocollapse */\n\n\nNgxsFormPluginModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsFormPluginModule,\n  declarations: [FormDirective],\n  imports: [ReactiveFormsModule],\n  exports: [FormDirective]\n});\n/** @nocollapse */\n\nNgxsFormPluginModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[ReactiveFormsModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsFormPluginModule, [{\n    type: NgModule,\n    args: [{\n      imports: [ReactiveFormsModule],\n      declarations: [FormDirective],\n      exports: [FormDirective]\n    }]\n  }], null, null);\n})();\n/**\n * The public api for consumers of @ngxs/form-plugin\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NgxsFormPlugin, NgxsFormPluginModule, ResetForm, SetFormDirty, SetFormDisabled, SetFormEnabled, SetFormPristine, UpdateForm, UpdateFormDirty, UpdateFormErrors, UpdateFormStatus, UpdateFormValue, FormDirective as ɵFormDirective }; //# sourceMappingURL=ngxs-form-plugin.js.map",
  "map": null,
  "metadata": {},
  "sourceType": "module"
}
